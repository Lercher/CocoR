/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University
with token inheritance by Martin Lercher, Singhammer dtSoftware Munich

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/
-->begin
using System;
using System.Collections;
using System.Collections.Generic;

-->namespace

public class Parser {
-->constants
	const bool _T = true;
	const bool _x = false;
	const string _DuplicateSymbol = "{0} '{1}' declared twice in '{2}'";
	const string _MissingSymbol ="{0} '{1}' not declared in '{2}'";
	const int minErrDist = 2;
	
	public Scanner scanner;
	public Errors  errors;
	public List<Alternative> tokens = new List<Alternative>();
	
	BitArray alt;
	Symboltable[] altst;

	public Token t;    // last recognized token
	public Token la;   // lookahead token
	int errDist = minErrDist;

-->declarations

	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	

	void Get () {
		for (;;) {
			t = la;
			if (t.kind != _EOF) {
				tokens.Add(new Alternative(t, alt, altst));
				_newAlt();
			}
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
			la = t;
		}
	}

	void _newAlt() {
		alt = new BitArray(maxT+1);
		altst = new Symboltable[maxT+1];
	}

	void addAlt(int kind) {
		alt[kind] = true;
	}

	// a terminal tokenclass of kind kind is restricted to this symbol table 
	void addAlt(int kind, Symboltable st) {
		// take the root scope, if it is the only scope,
		// make a copy of the scope stack otherwise, but preserve the list references
		altst[kind] = st.CapturingClone();
	}

	void addAlt(int[] range) {
		foreach(int kind in range)
			addAlt(kind);
	}

	void addAlt(bool[,] pred, int line) {
		for(int kind = 0; kind < maxT; kind++)
			if (pred[line, kind])
				addAlt(kind);
	}

	bool isKind(Token t, int n) {
		int k = t.kind;
		while(k >= 0) {
			if (k == n) return true;
			k = tBase[k];
		}
		return false;
	}
	
	void Expect (int n) {
		if (isKind(la, n)) Get(); else { SynErr(n); }
	}
	
	// is the lookahead token la a start of the production s?
	bool StartOf (int s) {
		return set[s, la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (isKind(la, n)) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}


	bool WeakSeparator(int n, int syFol, int repFol) {
		int kind = la.kind;
		if (isKind(la, n)) {Get(); return true;}
		else if (StartOf(repFol)) {return false;}
		else {
			SynErr(n);
			while (!(set[syFol, kind] || set[repFol, kind] || set[0, kind])) {
				Get();
				kind = la.kind;
			}
			return StartOf(syFol);
		}
	}

	
-->productions

	public void Parse() {
		la = new Token();
		la.val = "";
		_newAlt();		
		Get();
-->parseRoot
	}
	
	// a token's base type
	static readonly int[] tBase = {
-->tbase
	};

	// a token's name
	public static readonly string[] tName = {
-->tname
	};

	// states that a particular production (1st index) can start with a particular token (2nd index)
	static readonly bool[,] set0 = {
-->initialization0
	};

	// as set0 but with token inheritance taken into account
	static readonly bool[,] set = {
-->initialization
	};
} // end Parser


public class Errors {
	public int count = 0;                                    // number of errors detected
	public System.IO.TextWriter errorStream = Console.Out;   // error messages go to this stream
	public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text

	public virtual void SynErr (int line, int col, int n) {
		string s;
		switch (n) {
-->errors
			default: s = "error " + n; break;
		}
		errorStream.WriteLine(errMsgFormat, line, col, s);
		count++;
	}

	public virtual void SemErr (int line, int col, string s) {
		errorStream.WriteLine(errMsgFormat, line, col, s);
		count++;
	}
	
	public virtual void SemErr (string s) {
		errorStream.WriteLine(s);
		count++;
	}
	
	public virtual void Warning (int line, int col, string s) {
		errorStream.WriteLine(errMsgFormat, line, col, s);
	}
	
	public virtual void Warning(string s) {
		errorStream.WriteLine(s);
	}
} // Errors


public class FatalError: Exception {
	public FatalError(string m): base(m) {}
}

public class Alternative {
	public readonly Token t;
	public readonly BitArray alt;
	public readonly Symboltable[] st;

	public Alternative(Token t, BitArray alt, Symboltable[] st) {
		this.t = t;
		this.alt = alt;
		this.st = st;
	}
}

public class Symboltable {
	private Stack<List<string>> scopes;
	public readonly string name;
	public readonly bool ignoreCase;

	public Symboltable(string name, bool ignoreCase) {
		this.name = name;
		this.ignoreCase = ignoreCase;
		this.scopes = new Stack<List<string>>();
		pushNewScope();		
	}

	private Symboltable(Symboltable st) {
		this.name = st.name;
		this.ignoreCase = st.ignoreCase;

		// yes, twice to preserve order.
		// and yes, we intentionally keep the list references, so that we capture all
		// future additions to the existing lists
		this.scopes = new Stack<List<string>>(new Stack<List<string>>(st.scopes));		 		
	}

	// make a clone of all scopes
	// but recording all further additions to the currently present scopes
	public Symboltable CapturingClone() {
		if (scopes.Count == 1) return this;
		return new Symboltable(this);
	}

	void pushNewScope() {
		scopes.Push(new List<string>());
	}

	void popScope() {
		if (scopes.Count > 1)
			scopes.Pop();
	}

	public IDisposable createScope() {
		pushNewScope();
		return new Popper(this);
	} 

	public List<string> currentScope {
		get { return scopes.Peek(); } 
	}

	public bool Add(string s) {
		if (ignoreCase) s = s.ToLower();
		if (currentScope.Contains(s))
			return false;
		currentScope.Add(s);
		return true;
	}

	public bool Contains(string s) {
		if (ignoreCase) s = s.ToLower();
		foreach(List<string> list in scopes)
			if (list.Contains(s)) return true;
		return false;
	}

	public IEnumerable<string> items {
		get {
		    if (scopes.Count == 1) return currentScope;

			Symboltable all = new Symboltable(name, ignoreCase);
			foreach(List<string> list in scopes)
				foreach(string s in list)
					all.Add(s);
			return all.currentScope; 
		}
	}

	public int CountScopes {
		get { return scopes.Count; }
	}

	private class Popper : IDisposable {
		private readonly Symboltable st;

		public Popper(Symboltable st) {
			this.st = st;
		}

		public void Dispose() {
			st.popScope();
		}
	}
}
