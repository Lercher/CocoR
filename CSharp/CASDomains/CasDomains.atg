COMPILER CASDomains

CHARACTERS
	uppercaseletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
	digit    		= "0123456789".
	underscore		= "_".
	cr				= "\r".
	lf 				= "\n".
	tab				= "\t".
	stringCh  		= ANY - '"' - cr - lf.
	
TOKENS
	dbcode			= uppercaseletter {uppercaseletter | digit | underscore}.
	twodigitnumber	= digit[digit].
	string 			= '"' { stringCh } '"'.
	domain			= "domain".
	end				= "end".
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE cr + lf + tab

SYMBOLTABLES
	lang STRICT.
	langstring STRICT.
	domains STRICT.
	values STRICT.

PRODUCTIONS

/* 	
	AST Extension described
	----------------------------------------
	Use a stack.
	Each production call pushes an object marker on the stack.
	On return of a production method, pop until object marker ist found, form lists of list elements and 
	form an anonymous object, push it on the stack. At toplevel provide the only item on the stack as AST.
	...'  - as postfix, instead of t, push Prime(t) on the stack. The function Prime: Token -> Token has 
	     to be defined as a target language function.
	...=ident - as postfix, instead of t, create an ad hoc token t with t.val = ident
	Now, if parsing a terminal t: 
	#  - push t as literal
	## - push t as literal list element
	^prop  - push t as property prop, if prop missing use sym.name.lowerd
	^^prop - push t as property prop list element, if prop missing use sym.name.lowerd
	If parsing a nonterminal, pop the object o. If marked with ^ or #:
	#, ## - push o as literal or literal list element
	^, ^^ - push o as property or property list elements 
*/

	// names defining symbols
	LanguageName = 
		dbcode>lang 					//#
		| string>langstring 			//#'
	.
	
	DomainName = 
		dbcode>domains 					//#
		| string>domains 				//#'
	.
	
	ValueName = 
		dbcode>values 					//#
		| string>values 				//#'
	.

	// using names
	UseLanguageName = 
		dbcode:lang 					//#
		| string:langstring 			//#'
	.


	CASDomains =
		"casdomains" 
		Languages						//^
		{ Domain						//^^domains 
		}
	.
				
	Languages = 
		"languages"
		LanguageName 					//##
		{ LanguageName 					//## 
		}
	.

				
	Domain SCOPES(values) = 
		SYNC domain 
		DomainName 						//^name		
		[ "orfi" ]		 				//^orfi = 1			
		[ "length" twodigitnumber		//^length 
		]
		Translations					//^
		Domainvalue						//^^values 
		{ Domainvalue 					//^^values
		}
		end domain
	.
	
	Domainvalue = 
		SYNC "value"
		ValueName						//^
		TranslationsWithHelptext		//^translations
	.

	Translations 
		USEONCE(lang, langstring) 
		USEALL(lang, langstring)
	= 
		{
		  UseLanguageName				//^language
		  string						//^translation
		} 
		.

	TranslationsWithHelptext 
		USEONCE(lang, langstring) 
		USEALL(lang, langstring)
	= 
		{
		  UseLanguageName				//^language
		  string						//^translation
		  string						//^helptext
		} 
		.
	
END CASDomains .