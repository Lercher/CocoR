// cls & pushd .. & build & popd & cocbuild1.bat

COMPILER CASDomains

	public override void Prime(Token t) { 
		//if (t.kind == _string) 
		t.val = t.val.Substring(1, t.val.Length - 2);
	}


CHARACTERS
	uppercaseletter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".
	digit    		= "0123456789".
	underscore		= "_".
	cr				= "\r".
	lf 				= "\n".
	tab				= "\t".
	stringCh  		= ANY - '"' - cr - lf.
	
TOKENS
	dbcode			= uppercaseletter {uppercaseletter | digit | underscore}.
	twodigitnumber	= digit[digit].
	string 			= '"' { stringCh } '"'.
	domain			= "domain".
	end				= "end".
	
COMMENTS FROM "//" TO lf
COMMENTS FROM "/*" TO "*/" NESTED

IGNORE cr + lf + tab

SYMBOLTABLES
	lang STRICT.
	langstring STRICT.
	domains STRICT.
	values STRICT.

PRODUCTIONS

/* 	
	AST Extension described
	----------------------------------------
	Use a stack.
	Each production call pushes an object marker on the stack.
	On return of a production method, pop until object marker ist found, merge them into an anonymous object, push it on the stack. 
	At toplevel provide the only item on the stack as the resulting AST.
	...'  - as postfix, instead of t, push Prime(t) on the stack. The function Prime: Token -> Token has 
	     to be defined as a target language function.
	...=ident - as postfix, instead of t hatch ident.
	Now, if parsing a terminal t: 
	#:prop  - hatch - push t as literal with name prop = "hatch (hash with t) a terminal". If prop missing, don't use a name.
	##:prop - hatch list - push t as literal list element with list name prop = "hatch (hash with t) multiple terminals". If prop missing, don't use a list name.
	^:prop  - send upwards - give the top object the name prop = "send up as prop". If prop missing use sym.name.lowerd.
	^^:prop - send list upwards - create a list named prop and add the top object = "send up multiple as prop". If prop missing use sym.name.lowerd.
	If parsing a nonterminal, pop the object o. If marked with ^ or #:
	#, ## - push o as literal or literal list element
	^, ^^ - push o as property or property list elements 
*/

	// names defining symbols
	LanguageName = 
		dbcode>lang 					##
		| string>langstring 			##'
	.
	
	DomainName = 
		dbcode>domains 					#
		| string>domains 				#'
	.
	
	ValueName = 
		dbcode>values 					#
		| string>values 				#'
	.

	// using names
	UseLanguageName = 
		dbcode:lang 					#
		| string:langstring 			#'
	.


	CASDomains =
		"casdomains" 
		Languages						^
		{ Domain						^^:domains 
		}
	.
				
	Languages = 
		"languages"
		LanguageName 					
		{ LanguageName 					 
		}
	.

				
	Domain SCOPES(values) = 
		SYNC domain 
		DomainName 						^:domain		
		[ "orfi"						#:orfi="t"
		]			
		[ "length" twodigitnumber		#:length 
		]
		Translations					^^
		Domainvalue						^^:values 
		{ Domainvalue 					^^:values
		}
		end domain
	.
	
	Domainvalue = 
		SYNC "value"
		ValueName						^:value
		TranslationsWithHelptext		^^:translations
	.

	Translations 
		USEONCE(lang, langstring) 
		USEALL(lang, langstring)
	= 
		{
		  UseLanguageName				^:lang
		  string						#':tl
		} 
		.

	TranslationsWithHelptext 
		USEONCE(lang, langstring) 
		USEALL(lang, langstring)
	= 
		{
		  UseLanguageName				^:lang
		  string						#':tl
		  string						#':help
		} 
		.
	
END CASDomains .