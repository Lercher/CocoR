'-------------------------------------------------------------------------------
'Tab.vb -- Symbol Table Management
'Compiler Generator Coco/R,
'Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
'extended by M. Loeberbauer & A. Woess, Univ. of Linz
'with improvements by Pat Terry, Rhodes University
'
'This program is free software; you can redistribute it and/or modify it
'under the terms of the GNU General Public License as published by the
'Free Software Foundation; either version 2, or (at your option) any
'later version.
'
'This program is distributed in the hope that it will be useful, but
'WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
'or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
'for more details.
'
'You should have received a copy of the GNU General Public License along
'with this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'
'As an exception, it is allowed to write an extension of Coco/R that is
'used as a plugin in non-free software.
'
'If not otherwise stated, any source code generated by Coco/R (other than
'Coco/R itself) does not fall under the GNU General Public License.
'-------------------------------------------------------------------------------
Option Compare Binary
Option Explicit On
Option Strict On

Imports System
Imports System.Collections
Imports System.IO
Imports System.Text

Namespace at.jku.ssw.Coco

	Public Class Position     ' position of source code stretch (e.g. semantic action, resolver expressions)
		Public ReadOnly beg   As Integer ' start relative to the beginning of the file
		Public ReadOnly [end] As Integer ' end of stretch
		Public ReadOnly col   As Integer ' column number of start position
		Public ReadOnly line  As Integer ' line number of start position
		Public Sub New(ByVal beg As Integer, ByVal [end] As Integer, ByVal col As Integer, ByVal line As Integer)
			Me.beg   = beg
			Me.[end] = [end]
			Me.col   = col
			Me.line  = line
		End Sub
	End Class

	Public Class Symbol
		' token kinds
		Public Const fixedToken    As Integer = 0 ' e.g. 'a' ('b' | 'c') (structure of literals)
		Public Const classToken    As Integer = 1 ' e.g. digit {digit}   (at least one char class)
		Public Const litToken      As Integer = 2 ' e.g. "while"
		Public Const classLitToken As Integer = 3 ' e.g. letter {letter} but without literals that have the same structure
		Public       n             As Integer     ' symbol number
		Public       typ           As Integer     ' t, nt, pr, unknown, rslv /* ML 29_11_2002 slv added */ /* AW slv --> rslv */
		Public       name          As String      ' symbol name
		Public       graph         As Node        ' nt: to first node of syntax graph
		Public       tokenKind     As Integer     ' t:  token kind (fixedToken, classToken, ...)
		Public       deletable     As Boolean     ' nt: true if nonterminal is deletable
		Public       firstReady    As Boolean     ' nt: true if terminal start symbols have already been computed
		Public       first         As BitArray    ' nt: terminal start symbols
		Public       follow        As BitArray    ' nt: terminal followers
		Public       nts           As BitArray    ' nt: nonterminals whose followers have to be added to this sym
		Public       line          As Integer     ' source text line number of item in this node
		Public       attrPos       As Position    ' nt: position of attributes in source text (or null)
		Public       semPos        As Position    ' pr: pos of semantic action in source text (or null)
		                                          ' nt: pos of local declarations in source text (or null)
		Public 		 [inherits]    As Symbol 	  ' optional, token from which this token derives
		
		Public Sub New(ByVal typ As Integer, ByVal name As String, ByVal line As Integer)
			Me.typ = typ
			Me.name = name
			Me.line = line
		End Sub
	End Class

	Public Class Node
		' constants for node kinds
		Public Const t            As Integer =  1 ' terminal symbol
		Public Const pr           As Integer =  2 ' pragma
		Public Const nt           As Integer =  3 ' nonterminal symbol
		Public Const clas         As Integer =  4 ' character class
		Public Const chr          As Integer =  5 ' character
		Public Const wt           As Integer =  6 ' weak terminal symbol
		Public Const any          As Integer =  7 '
		Public Const eps          As Integer =  8 ' empty
		Public Const sync         As Integer =  9 ' synchronization symbol
		Public Const sem          As Integer = 10 ' semantic action: (. .)
		Public Const alt          As Integer = 11 ' alternative: |
		Public Const iter         As Integer = 12 ' iteration: { }
		Public Const opt          As Integer = 13 ' option: [ ]
		Public Const rslv         As Integer = 14 ' resolver expr
		Public Const normalTrans  As Integer =  0 ' transition codes
		Public Const contextTrans As Integer =  1
		Public       n            As Integer      ' node number
		Public       typ          As Integer      ' t, nt, wt, chr, clas, any, eps, sem, sync, alt, iter, opt, rslv
		Public       [next]       As Node         ' to successor node
		Public       down         As Node         ' alt: to next alternative
		Public       [sub]        As Node         ' alt, iter, opt: to first node of substructure
		Public       up           As Boolean      ' true: "next" leads to successor in enclosing structure
		Public       sym          As Symbol       ' nt, t, wt: symbol represented by this node
		Public       val          As Integer      ' chr:  ordinal character value
		                                          ' clas: index of character class
		Public       code         As Integer      ' chr, clas: transition code
		Public       [set]        As BitArray     ' any, sync: the set represented by this node
		Public       pos          As Position     ' nt, t, wt: pos of actual attributes
		                                          ' sem:       pos of semantic action in source text
		                                          ' rslv:      pos of resolver in source text
		Public       line         As Integer      ' source text line number of item in this node
		Public       state        As State        ' DFA state corresponding to this node (only used in DFA.ConvertToStates)
		Public Sub New(ByVal typ As Integer, ByVal sym As Symbol, ByVal line As Integer)
			Me.typ = typ
			Me.sym = sym
			Me.line = line
		End Sub
	End Class

	Public Class Graph
		Public l As Node ' left end of graph = head
		Public r As Node ' right end of graph = list of nodes to be linked to successor graph
		Public Sub New()
			l = Nothing
			r = Nothing
		End Sub
		Public Sub New(ByVal left As Node, ByVal right As Node)
			l = left
			r = right
		End Sub
		Public Sub New(ByVal p As Node)
			l = p
			r = p
		End Sub
	End Class

	Public Class Sets
		Public Shared Function Elements(ByVal s As BitArray) As Integer
			Dim max As Integer = s.Count
			Dim n As Integer = 0
			For i As Integer = 0 To max - 1
				If s(i) Then
					n += 1
				End If
			Next
			Return n
		End Function
		Public Shared Shadows Function Equals(ByVal a As BitArray, ByVal b As BitArray) As Boolean
			Dim max As Integer = a.Count
			For i As Integer = 0 To max - 1
				If a(i) <> b(i) Then
					Return False
				End If
			Next
			Return True
		End Function
		Public Shared Function Intersect(ByVal a As BitArray, ByVal b As BitArray) As Boolean
			' a * b != {}
			Dim max As Integer = a.Count
			For i As Integer = 0 To max - 1
				If a(i) AndAlso b(i) Then
					Return True
				End If
			Next
			Return False
		End Function
		Public Shared Sub Subtract(ByVal a As BitArray, ByVal b As BitArray)
			' a = a - b
			Dim c As BitArray = DirectCast(b.Clone(), BitArray)
			a.[And](c.[Not]())
		End Sub
	End Class

	Public Class CharClass
		Public n     As Integer ' class number
		Public name  As String  ' class name
		Public [set] As CharSet ' set representing the class
		Public Sub New(ByVal name As String, ByVal s As CharSet)
			Me.name = name
			Me.[set] = s
		End Sub
	End Class

	Public Class Tab
		Public  semDeclPos  As Position                        ' position of global semantic declarations
		Public  ignored     As CharSet                         ' characters ignored by the scanner
		Public  ddt()       As Boolean    = New Boolean(10) {} ' debug and test switches
		Public  gramSy      As Symbol                          ' root nonterminal, filled by ATG
		Public  eofSy       As Symbol                          ' end of file symbol
		Public  noSym       As Symbol                          ' used in case of an error
		Public  allSyncSets As BitArray                        ' union of all synchronisation sets
		Public  literals    As Hashtable                       ' symbols that are used as literals
		Public  srcName     As String                          ' name of the atg file (including path)
		Public  srcDir      As String                          ' directory path of the atg file
		Public  nsName      As String                          ' namespace for generated files
		Public  frameDir    As String                          ' directory containing the frame files
		Public  outDir      As String                          ' directory for generated Files
		Public  checkEOF    As Boolean    = True               ' should coco generate a check for EOF at the end of Parser.Parse()?
		Public  emitLines   As Boolean                         ' emit #line pragmas for semantic actions in the generated parser
		Private visited     As BitArray                        ' mark list for graph traversals
		Private curSy       As Symbol                          ' current symbol in computation of sets
		Private parser      As Parser                          ' other Coco objects
		Private trace       As TextWriter
		Private errors      As Errors
		Public Sub New(ByVal parser As Parser)
			Me.parser = parser
			trace = parser.trace
			errors = parser.errors
			eofSy = NewSym(Node.t, "EOF", 0)
			dummyNode = NewNode(Node.eps, DirectCast(Nothing, Symbol), 0)
			literals = New Hashtable()
		End Sub
		'---------------------------------------------------------------------------
		'  Symbol list management
		'---------------------------------------------------------------------------
		Public terminals As New ArrayList()
		Public pragmas As New ArrayList()
		Public nonterminals As New ArrayList()
		Private tKind() As String = {"fixedToken", "classToken", "litToken", "classLitToken"}
		Public Function NewSym(ByVal typ As Integer, ByVal name As String, ByVal line As Integer) As Symbol
			If name.Length = 2 AndAlso name(0) = """"C Then
				parser.SemErr("empty token not allowed")
				name = "???"
			End If
			Dim sym As New Symbol(typ, name, line)
			Select Case typ
				Case Node.t
					sym.n = terminals.Count
					terminals.Add(sym)
				Case Node.pr
					pragmas.Add(sym)
				Case Node.nt
					sym.n = nonterminals.Count
					nonterminals.Add(sym)
			End Select
			Return sym
		End Function
		Public Function FindSym(ByVal name As String) As Symbol
			For Each s As Symbol In terminals
				If s.name = name Then
					Return s
				End If
			Next
			For Each s As Symbol In nonterminals
				If s.name = name Then
					Return s
				End If
			Next
			Return Nothing
		End Function
		Private Function Num(ByVal p As Node) As Integer
			If p Is Nothing Then
				Return 0
			Else
				Return p.n
			End If
		End Function
		Private Sub PrintSym(ByVal sym As Symbol)
			trace.Write("{0,3} {1,-14} {2}", sym.n, Name(sym.name), nTyp(sym.typ))
			If sym.attrPos Is Nothing Then
				trace.Write(" false ")
			Else
				trace.Write(" true  ")
			End If
			If sym.typ = Node.nt Then
				trace.Write("{0,5}", Num(sym.graph))
				If sym.deletable Then
					trace.Write(" true  ")
				Else
					trace.Write(" false ")
				End If
			Else
				trace.Write(Space(12))
			End If
			trace.WriteLine("{0,5} {1}", sym.line, tKind(sym.tokenKind))
		End Sub
		Public Sub PrintSymbolTable()
			trace.WriteLine()
			trace.WriteLine("Symbol Table:")
			trace.WriteLine("------------")
			trace.WriteLine()
			trace.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind")
			For Each sym As Symbol In terminals
				PrintSym(sym)
			Next
			For Each sym As Symbol In pragmas
				PrintSym(sym)
			Next
			For Each sym As Symbol In nonterminals
				PrintSym(sym)
			Next
			trace.WriteLine()
			trace.WriteLine("Literal Tokens:")
			trace.WriteLine("--------------")
			For Each e As DictionaryEntry In literals
				Dim litName As String = DirectCast(e.Value, Symbol).name
				Dim litKey As String = DirectCast(e.Key, String)
				trace.WriteLine("_" & litName & " = " & litKey & ".")
			Next
			trace.WriteLine()
		End Sub
		Public Sub PrintSet(ByVal s As BitArray, ByVal indent As Integer)
			Dim col As Integer
			Dim len As Integer
			col = indent
			For Each sym As Symbol In terminals
				If s(sym.n) Then
					len = sym.name.Length
					If col + len >= 80 Then
						trace.WriteLine()
						For col = 1 To indent - 1
							trace.Write(" ")
						Next
					End If
					trace.Write("{0} ", sym.name)
					col += len + 1
				End If
			Next
			If col = indent Then
				trace.Write("-- empty set --")
			End If
			trace.WriteLine()
		End Sub
		'---------------------------------------------------------------------------
		'  Syntax graph management
		'---------------------------------------------------------------------------
		Public nodes As New ArrayList()
		Public nTyp() As String = { _
			Space(4), _
			"t   ", _
			"pr  ", _
			"nt  ", _
			"clas", _
			"chr ", _
			"wt  ", _
			"any ", _
			"eps ", _
			"sync", _
			"sem ", _
			"alt ", _
			"iter", _
			"opt ", _
			"rslv" _
		}
		Private dummyNode As Node
		Public Function NewNode(ByVal typ As Integer, ByVal sym As Symbol, ByVal line As Integer) As Node
			Dim node As New Node(typ, sym, line)
			node.n = nodes.Count
			nodes.Add(node)
			Return node
		End Function
		Public Function NewNode(ByVal typ As Integer, ByVal [sub] As Node) As Node
			Dim node As Node = NewNode(typ, DirectCast(Nothing, Symbol), 0)
			node.[sub] = [sub]
			Return node
		End Function
		Public Function NewNode(ByVal typ As Integer, ByVal val As Integer, ByVal line As Integer) As Node
			Dim node As Node = NewNode(typ, DirectCast(Nothing, Symbol), line)
			node.val = val
			Return node
		End Function
		Public Sub MakeFirstAlt(ByVal g As Graph)
			g.l = NewNode(Node.alt, g.l)
			g.l.line = g.l.[sub].line
			g.r.up = true
			g.l.[next] = g.r
			g.r = g.l
		End Sub
		' The result will be in g1
		Public Sub MakeAlternative(ByVal g1 As Graph, ByVal g2 As Graph)
			g2.l = NewNode(Node.alt, g2.l)
			g2.l.line = g2.l.[sub].line
			g2.l.up = true
			g2.r.up = true
			Dim p As Node = g1.l
			While p.down IsNot Nothing
				p = p.down
			End While
			p.down = g2.l
			p = g1.r
			While p.[next] IsNot Nothing
				p = p.[next]
			End While
			' append alternative to g1 end list
			p.[next] = g2.l
			' append g2 end list to g1 end list
			g2.l.[next] = g2.r
		End Sub
		' The result will be in g1
		Public Sub MakeSequence(ByVal g1 As Graph, ByVal g2 As Graph)
			Dim p As Node = g1.r.[next]
			g1.r.[next] = g2.l
			' link head node
			While p IsNot Nothing
				' link substructure
				Dim q As Node = p.[next]
				p.[next] = g2.l
				p = q
			End While
			g1.r = g2.r
		End Sub
		Public Sub MakeIteration(ByVal g As Graph)
			g.l = NewNode(Node.iter, g.l)
			g.r.up = true
			Dim p As Node = g.r
			g.r = g.l
			While p IsNot Nothing
				Dim q As Node = p.[next]
				p.[next] = g.l
				p = q
			End While
		End Sub
		Public Sub MakeOption(ByVal g As Graph)
			g.l = NewNode(Node.opt, g.l)
			g.r.up = true
			g.l.[next] = g.r
			g.r = g.l
		End Sub
		Public Sub Finish(ByVal g As Graph)
			Dim p As Node = g.r
			While p IsNot Nothing
				Dim q As Node = p.[next]
				p.[next] = Nothing
				p = q
			End While
		End Sub
		Public Sub DeleteNodes()
			nodes = New ArrayList()
			dummyNode = NewNode(Node.eps, DirectCast(Nothing, Symbol), 0)
		End Sub
		Public Function StrToGraph(ByVal str As String) As Graph
			Dim s As String = Unescape(str.Substring(1, str.Length - 2))
			If s.Length = 0 Then
				parser.SemErr("empty token not allowed")
			End If
			Dim g As New Graph()
			g.r = dummyNode
			For i As Integer = 0 To s.Length - 1
				Dim p As Node = NewNode(Node.chr, AscW(s(i)), 0)
				g.r.[next] = p
				g.r = p
			Next
			g.l = dummyNode.[next]
			dummyNode.[next] = Nothing
			Return g
		End Function
		Public Sub SetContextTrans(ByVal p As Node)
			' set transition code in the graph rooted at p
			While p IsNot Nothing
				If p.typ = Node.chr OrElse p.typ = Node.clas Then
					p.code = Node.contextTrans
				ElseIf p.typ = Node.opt OrElse p.typ = Node.iter Then
					SetContextTrans(p.[sub])
				ElseIf p.typ = Node.alt Then
					SetContextTrans(p.[sub])
					SetContextTrans(p.down)
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
		End Sub
		'------------ graph deletability check -------------------------------------
		Public Shared Function DelGraph(ByVal p As Node) As Boolean
			Return p Is Nothing OrElse DelNode(p) AndAlso DelGraph(p.[next])
		End Function
		Public Shared Function DelSubGraph(ByVal p As Node) As Boolean
			Return p Is Nothing OrElse DelNode(p) AndAlso (p.up OrElse DelSubGraph(p.[next]))
		End Function
		Public Shared Function DelNode(ByVal p As Node) As Boolean
			If p.typ = Node.nt Then
				Return p.sym.deletable
			ElseIf p.typ = Node.alt Then
				Return DelSubGraph(p.[sub]) OrElse p.down IsNot Nothing AndAlso DelSubGraph(p.down)
			Else
				Return p.typ = Node.iter OrElse p.typ = Node.opt OrElse p.typ = Node.sem OrElse p.typ = Node.eps OrElse p.typ = Node.rslv OrElse p.typ = Node.sync
			End If
		End Function
		'----------------- graph printing ------------------------------------------
		Private Function Ptr(ByVal p As Node, ByVal up As Boolean) As String
			Dim lptr As String
			If p Is Nothing Then
				lptr = "0"
			Else
				lptr = p.n.ToString()
			End If
			If up Then
				lptr = "-" & lptr
			End If
			Return lptr
		End Function
		Private Function Pos(ByVal posPos As Position) As String
			If posPos Is Nothing Then
				Return Space(5)
			Else
				Return [String].Format("{0,5}", posPos.beg)
			End If
		End Function
		Public Function Name(ByVal strName As String) As String
			Return (strName & Space(12)).Substring(0, 12)
			' found no simpler way to get the first 12 characters of the strName
			' padded with blanks on the right
		End Function
		Public Sub PrintNodes()
			trace.WriteLine("Graph nodes:")
			trace.WriteLine("----------------------------------------------------")
			trace.WriteLine("   n type name          next  down   sub   pos  line")
			trace.WriteLine("                               val  code")
			trace.WriteLine("----------------------------------------------------")
			For Each p As Node In nodes
				trace.Write("{0,4} {1} ", p.n, nTyp(p.typ))
				If p.sym IsNot Nothing Then
					trace.Write("{0,12} ", Name(p.sym.name))
				ElseIf p.typ = Node.clas Then
					Dim c As CharClass = DirectCast(classes(p.val), CharClass)
					trace.Write("{0,12} ", Name(c.name))
				Else
					trace.Write(Space(13))
				End If
				trace.Write("{0,5} ", Ptr(p.[next], p.up))
				Select Case p.typ
					Case Node.t, Node.nt, Node.wt
						trace.Write("             {0,5}", Pos(p.pos))
					Case Node.chr
						trace.Write("{0,5} {1,5}       ", p.val, p.code)
					Case Node.clas
						trace.Write("      {0,5}       ", p.code)
					Case Node.alt, Node.iter, Node.opt
						trace.Write("{0,5} {1,5}       ", Ptr(p.down, False), Ptr(p.[sub], False))
					Case Node.sem
						trace.Write("             {0,5}", Pos(p.pos))
					Case Node.eps, Node.any, Node.sync
						trace.Write(Space(18))
				End Select
				trace.WriteLine("{0,5}", p.line)
			Next
			trace.WriteLine()
		End Sub
		'---------------------------------------------------------------------------
		'  Character class management
		'---------------------------------------------------------------------------
		Public Classes As New ArrayList()
		Public dummyName As Integer = AscW("A"C)
		Public Function NewCharClass(ByVal name As String, ByVal s As CharSet) As CharClass
			If name = "#" Then
				name = "#" & ChrW(dummyName)
				dummyName += 1
			End If
			Dim c As New CharClass(name, s)
			c.n = classes.Count
			classes.Add(c)
			Return c
		End Function
		Public Function FindCharClass(ByVal name As String) As CharClass
			For Each c As CharClass In classes
				If c.name = name Then
					Return c
				End If
			Next
			Return Nothing
		End Function
		Public Function FindCharClass(ByVal s As CharSet) As CharClass
			For Each c As CharClass In classes
				If s.Equals(c.[set]) Then
					Return c
				End If
			Next
			Return Nothing
		End Function
		Public Function CharClassSet(ByVal i As Integer) As CharSet
			Return (DirectCast(classes(i), CharClass)).[set]
		End Function
		'----------- character class printing
		Private Function Ch(ByVal intChar As Integer) As String
			If intChar < AscW(" "C) OrElse intChar >= 127 OrElse intChar = AscW("'"C) OrElse intChar = AscW("\"C) Then
				Return intChar.ToString()
			Else
				Return [String].Format("'{0}'", ChrW(intChar))
			End If
		End Function
		Private Sub WriteCharSet(ByVal s As CharSet)
			Dim r As CharSet.Range = s.head
			While r IsNot Nothing
				If r.from < r.[to] Then
					trace.Write(Ch(r.from) & ".." & Ch(r.[to]) & " ")
				Else
					trace.Write(Ch(r.from) & " ")
				End If
				r = r.[next]
			End While
		End Sub
		Public Sub WriteCharClasses()
			For Each c As CharClass In classes
				trace.Write("{0,-10}: ", c.name)
				WriteCharSet(c.[set])
				trace.WriteLine()
			Next
			trace.WriteLine()
		End Sub
		'---------------------------------------------------------------------------
		'  Symbol set computations
		'---------------------------------------------------------------------------
		' Computes the first set for the graph rooted at p
		Private Function First0(ByVal p As Node, ByVal mark As BitArray) As BitArray
			Dim fs As New BitArray(terminals.Count)
			While p IsNot Nothing AndAlso Not mark(p.n)
				mark(p.n) = True
				Select Case p.typ
					Case Node.nt
						If p.sym.firstReady Then
							fs.[Or](p.sym.first)
						Else
							fs.[Or](First0(p.sym.graph, mark))
						End If
					Case Node.t, Node.wt
						fs(p.sym.n) = True
					Case Node.any
						fs.[Or](p.[set])
					Case Node.alt
						fs.[Or](First0(p.[sub], mark))
						fs.[Or](First0(p.down, mark))
					Case Node.iter, Node.opt
						fs.[Or](First0(p.[sub], mark))
				End Select
				If Not DelNode(p) Then
					Exit While
				End If
				p = p.[next]
			End While
			Return fs
		End Function
		Public Function First(ByVal p As Node) As BitArray
			Dim fs As BitArray = First0(p, New BitArray(nodes.Count))
			If ddt(3) Then
				trace.WriteLine()
				If p IsNot Nothing Then
					trace.WriteLine("First: node = {0}", p.n)
				Else
					trace.WriteLine("First: node = null")
				End If
				PrintSet(fs, 0)
			End If
			Return fs
		End Function
		Private Sub CompFirstSets()
			For Each sym As Symbol In nonterminals
				sym.first = New BitArray(terminals.Count)
				sym.firstReady = False
			Next
			For Each sym As Symbol In nonterminals
				sym.first = First(sym.graph)
				sym.firstReady = True
			Next
		End Sub
		Private Sub CompFollow(ByVal p As Node)
			While p IsNot Nothing AndAlso Not visited(p.n)
				visited(p.n) = True
				If p.typ = Node.nt Then
					Dim s As BitArray = First(p.[next])
					p.sym.follow.[Or](s)
					If DelGraph(p.[next]) Then
						p.sym.nts(curSy.n) = True
					End If
				ElseIf p.typ = Node.opt OrElse p.typ = Node.iter Then
					CompFollow(p.[sub])
				ElseIf p.typ = Node.alt Then
					CompFollow(p.[sub])
					CompFollow(p.down)
				End If
				p = p.[next]
			End While
		End Sub
		Private Sub Complete(ByVal sym As Symbol)
			If Not visited(sym.n) Then
				visited(sym.n) = True
				For Each s As Symbol In nonterminals
					If sym.nts(s.n) Then
						Complete(s)
						sym.follow.[Or](s.follow)
						If sym Is curSy Then
							sym.nts(s.n) = False
						End If
					End If
				Next
			End If
		End Sub
		Private Sub CompFollowSets()
			For Each sym As Symbol In nonterminals
				sym.follow = New BitArray(terminals.Count)
				sym.nts = New BitArray(nonterminals.Count)
			Next
			gramSy.follow(eofSy.n) = True
			visited = New BitArray(nodes.Count)
			For Each sym As Symbol In nonterminals
				' get direct successors of nonterminals
				curSy = sym
				CompFollow(sym.graph)
			Next
			For Each sym As Symbol In nonterminals
				' add indirect successors to followers
				visited = New BitArray(nonterminals.Count)
				curSy = sym
				Complete(sym)
			Next
		End Sub
		Private Function LeadingAny(ByVal p As Node) As Node
			If p Is Nothing Then
				Return Nothing
			End If
			Dim a As Node = Nothing
			If p.typ = Node.any Then
				a = p
			ElseIf p.typ = Node.alt Then
				a = LeadingAny(p.[sub])
				If a Is Nothing Then
					a = LeadingAny(p.down)
				End If
			ElseIf p.typ = Node.opt OrElse p.typ = Node.iter Then
				a = LeadingAny(p.[sub])
			ElseIf a Is Nothing AndAlso DelNode(p) AndAlso Not p.up Then
				a = LeadingAny(p.[next])
			End If
			Return a
		End Function
		Private Sub FindAS(ByVal p As Node) ' find ANY sets
			Dim a As Node
			While p IsNot Nothing
				If p.typ = Node.opt OrElse p.typ = Node.iter Then
					FindAS(p.[sub])
					a = LeadingAny(p.[sub])
					If a IsNot Nothing Then
						Sets.Subtract(a.[set], First(p.[next]))
					End If
				ElseIf p.typ = Node.alt Then
					Dim s1 As New BitArray(terminals.Count)
					Dim q As Node = p
					While q IsNot Nothing
						FindAS(q.[sub])
						a = LeadingAny(q.[sub])
						If a IsNot Nothing Then
							Sets.Subtract(a.[set], First(q.down).[Or](s1))
						Else
							s1.[Or](First(q.[sub]))
						End If
						q = q.down
					End While
				End If
				' Remove alternative terminals before ANY, in the following
				' examples a and b must be removed from the ANY set:
				' [a] ANY, or {a|b} ANY, or [a][b] ANY, or (a|) ANY, or
				' A = [a]. A ANY
				If (DelNode(p)) Then
					a = LeadingAny(p.next)
					If (a IsNot Nothing) Then
						Dim q As Node
						If p.typ = Node.nt Then
							q = p.sym.graph
						Else
							q = p.sub
						End If
						Sets.Subtract(a.set, First(q))
					End If
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
		End Sub
		Private Sub CompAnySets()
			For Each sym As Symbol In nonterminals
				FindAS(sym.graph)
			Next
		End Sub
		Public Function Expected(ByVal p As Node, ByVal curSy As Symbol) As BitArray
			Dim s As BitArray = First(p)
			If DelGraph(p) Then
				s.[Or](curSy.follow)
			End If
			Return s
		End Function
		' does not look behind resolvers, only called during LL(1) test and in CheckRes
		Public Function Expected0(ByVal p As Node, ByVal curSy As Symbol) As BitArray
			If p.typ = Node.rslv Then
				Return New BitArray(terminals.Count)
			Else
				Return Expected(p, curSy)
			End If
		End Function
		Private Sub CompSync(ByVal p As Node)
			While p IsNot Nothing AndAlso Not visited(p.n)
				visited(p.n) = True
				If p.typ = Node.sync Then
					Dim s As BitArray = Expected(p.[next], curSy)
					s(eofSy.n) = True
					allSyncSets.[Or](s)
					p.[set] = s
				ElseIf p.typ = Node.alt Then
					CompSync(p.[sub])
					CompSync(p.down)
				ElseIf p.typ = Node.opt OrElse p.typ = Node.iter Then
					CompSync(p.[sub])
				End If
				p = p.[next]
			End While
		End Sub
		Private Sub CompSyncSets()
			allSyncSets = New BitArray(terminals.Count)
			allSyncSets(eofSy.n) = True
			visited = New BitArray(nodes.Count)
			For Each sym As Symbol In nonterminals
				curSy = sym
				CompSync(curSy.graph)
			Next
		End Sub
		Public Sub SetupAnys()
			For Each p As Node In nodes
				If p.typ = Node.any Then
					p.[set] = New BitArray(terminals.Count, True)
					p.[set](eofSy.n) = False
				End If
			Next
		End Sub
		Public Sub CompDeletableSymbols()
			Dim changed As Boolean
			Do
				changed = False
				For Each sym As Symbol In nonterminals
					If Not sym.deletable AndAlso sym.graph IsNot Nothing AndAlso DelGraph(sym.graph) Then
						sym.deletable = True
						changed = True
					End If
				Next
			Loop While changed
			For Each sym As Symbol In nonterminals
				If sym.deletable Then
					errors.Warning(Space(2) & sym.name & " deletable")
				End If
			Next
		End Sub
		Public Sub RenumberPragmas()
			Dim n As Integer = terminals.Count
			For Each sym As Symbol In pragmas
				sym.n = n
				n += 1
			Next
		End Sub
		Public Sub CompSymbolSets()
			CompDeletableSymbols()
			CompFirstSets()
			CompAnySets()
			CompFollowSets()
			CompSyncSets()
			If ddt(1) Then
				trace.WriteLine()
				trace.WriteLine("First & follow symbols:")
				trace.WriteLine("----------------------")
				trace.WriteLine()
				For Each sym As Symbol In nonterminals
					trace.WriteLine(sym.name)
					trace.Write("first:   ")
					PrintSet(sym.first, 10)
					trace.Write("follow:  ")
					PrintSet(sym.follow, 10)
					trace.WriteLine()
				Next
			End If
			If ddt(4) Then
				trace.WriteLine()
				trace.WriteLine("ANY and SYNC sets:")
				trace.WriteLine("-----------------")
				For Each p As Node In nodes
					If p.typ = Node.any OrElse p.typ = Node.sync Then
						trace.Write("{0,4} {1,4}: ", p.n, nTyp(p.typ))
						PrintSet(p.[set], 11)
					End If
				Next
			End If
		End Sub
		'---------------------------------------------------------------------------
		'  String handling
		'---------------------------------------------------------------------------
		Private Function Hex2Char(ByVal s As String) As Char
			Dim val As Integer = 0
			For i As Integer = 0 To s.Length - 1
				Dim ch As Char = s(i)
				If "0"C <= ch AndAlso ch <= "9"C Then
					val = 16 * val + (AscW(ch) - AscW("0"C))
				ElseIf "a"C <= ch AndAlso ch <= "f"C Then
					val = 16 * val + (10 + AscW(ch) - AscW("a"C))
				ElseIf "A"C <= ch AndAlso ch <= "F"C Then
					val = 16 * val + (10 + AscW(ch) - AscW("A"C))
				Else
					parser.SemErr("bad escape sequence in string or character")
				End If
			Next
			If val > AscW(Char.MaxValue) Then ' pdt
				parser.SemErr("bad escape sequence in string or character")
			End If
			Return ChrW(val)
		End Function
		Private Function Char2Hex(ByVal ch As Char) As String
			Dim w As New StringWriter()
			w.Write("\u{0:x4}", AscW(ch))
			Return w.ToString()
		End Function
		Public Function Unescape(ByVal s As String) As String
			' replaces escape sequences in s by their Unicode values.
			Dim buf As New StringBuilder()
			Dim i As Integer = 0
			While i < s.Length
				If s(i) = "\"C Then
					Select Case s(i + 1)
						Case "\"C :  buf.Append("\"C)    : i += 2
						Case "'"C :  buf.Append("'"C)    : i += 2
						Case """"C : buf.Append(""""C)   : i += 2
						Case "r"C :  buf.Append(vbCR)    : i += 2
						Case "n"C :  buf.Append(vbLf)    : i += 2
						Case "t"C :  buf.Append(vbTab)   : i += 2
						Case "0"C :  buf.Append(Chr( 0)) : i += 2
						Case "a"C :  buf.Append(Chr( 7)) : i += 2
						Case "b"C :  buf.Append(Chr( 8)) : i += 2
						Case "f"C :  buf.Append(Chr(12)) : i += 2
						Case "v"C :  buf.Append(Chr(11)) : i += 2
						Case "u"C, "x"C
							If i + 6 <= s.Length Then
								buf.Append(Hex2Char(s.Substring(i + 2, 4)))
								i += 6
							Else
								parser.SemErr("bad escape sequence in string or character")
								i = s.Length
							End If
						Case Else
							parser.SemErr("bad escape sequence in string or character")
							i += 2
					End Select
				Else
					buf.Append(s(i))
					i += 1
				End If
			End While
			Return buf.ToString()
		End Function
		Public Function Escape(ByVal s As String) As String
			Dim buf As New StringBuilder()
			For Each ch As Char In s
				Select Case ch
					Case "\"C     : buf.Append("\\")
					Case "'"C     : buf.Append("\'")
					Case """"C    : buf.Append("""""")
					Case ChrW( 9) : buf.Append("\t")
					Case ChrW(13) : buf.Append("\r")
					Case ChrW(10) : buf.Append("\n")
					Case Else
						If ch < " "C OrElse ch > Chr(127) Then
							buf.Append(Char2Hex(ch))
						Else
							buf.Append(ch)
						End If
				End Select
			Next
			Return buf.ToString()
		End Function
		'---------------------------------------------------------------------------
		'  Grammar checks
		'---------------------------------------------------------------------------
		Public Function GrammarOk() As Boolean
			Dim ok As Boolean = NtsComplete() AndAlso AllNtReached() AndAlso NoCircularProductions() AndAlso AllNtToTerm()
			If ok Then
				CheckResolvers()
				CheckLL1()
			End If
			Return ok
		End Function
		'--------------- check for circular productions ----------------------------
		Private Class CNode ' node of list for finding circular productions
			Public left As Symbol, right As Symbol
			Public Sub New(ByVal l As Symbol, ByVal r As Symbol)
				left = l
				right = r
			End Sub
		End Class
		Private Sub GetSingles(ByVal p As Node, ByVal singles As ArrayList)
			If p Is Nothing Then
				Return
			End If
			' end of graph
			If p.typ = Node.nt Then
				If p.up OrElse DelGraph(p.[next]) Then
					singles.Add(p.sym)
				End If
			ElseIf p.typ = Node.alt OrElse p.typ = Node.iter OrElse p.typ = Node.opt Then
				If p.up OrElse DelGraph(p.[next]) Then
					GetSingles(p.[sub], singles)
					If p.typ = Node.alt Then
						GetSingles(p.down, singles)
					End If
				End If
			End If
			If Not p.up AndAlso DelNode(p) Then
				GetSingles(p.[next], singles)
			End If
		End Sub
		Public Function NoCircularProductions() As Boolean
			Dim ok As Boolean
			Dim changed As Boolean
			Dim onLeftSide As Boolean
			Dim onRightSide As Boolean
			Dim list As New ArrayList()
			For Each sym As Symbol In nonterminals
				Dim singles As New ArrayList()
				GetSingles(sym.graph, singles) ' get nonterminals s such that sym-->s
				For Each s As Symbol In singles
					list.Add(New CNode(sym, s))
				Next
			Next
			Do
				changed = False
				Dim i As Integer = 0
				While True
					If list.Count = 0 Then Exit While
					if i >= list.Count Then Exit While
					Dim n As CNode = DirectCast(list(i), CNode)
					onLeftSide = False
					onRightSide = False
					For Each m As CNode In list
						If n.left Is m.right Then onRightSide = True
						If n.right Is m.left Then onLeftSide = True
					Next
					If Not onLeftSide OrElse Not onRightSide Then
						list.Remove(n)
						i -= 1
						changed = True
					End If
					i += 1
				End While
			Loop While changed
			ok = True
			For Each n As CNode In list
				ok = False
				errors.SemErr(Space(2) & n.left.name & " --> " & n.right.name)
			Next
			Return ok
		End Function
		'--------------- check for LL(1) errors ------------------------------------
		Private Sub LL1Error(ByVal cond As Integer, ByVal sym As Symbol)
			'Dim s As String = "  LL1 warning in " & curSy.name & ": "
			Dim s As String = "LL1 warning in " & curSy.name & ": "
			If sym IsNot Nothing Then
				s &= sym.name & " is "
			End If
			Select Case cond
				Case 1 : s &= "start of several alternatives"
				Case 2 : s &= "start & successor of deletable structure"
				Case 3 : s &= "an ANY node that matches no symbol"
				Case 4 : s &= "contents of [...] or {...} must not be deletable"
			End Select
			With curSy
				errors.Warning(.line, 1, s)
			End With
		End Sub
		Private Sub CheckOverlap(ByVal s1 As BitArray, ByVal s2 As BitArray, ByVal cond As Integer)
			For Each sym As Symbol In terminals
				If s1(sym.n) AndAlso s2(sym.n) Then
					LL1Error(cond, sym)
				End If
			Next
		End Sub
		Private Sub CheckAlts(ByVal p As Node)
			Dim s1 As BitArray
			Dim s2 As BitArray
			While p IsNot Nothing
				If p.typ = Node.alt Then
					Dim q As Node = p
					s1 = New BitArray(terminals.Count)
					While q IsNot Nothing
						' for all alternatives
						s2 = Expected0(q.[sub], curSy)
						CheckOverlap(s1, s2, 1)
						s1.[Or](s2)
						CheckAlts(q.[sub])
						q = q.down
					End While
				ElseIf p.typ = Node.opt OrElse p.typ = Node.iter Then
					If DelSubGraph(p.[sub]) Then
						LL1Error(4, Nothing)
					Else
						' e.g. [[...]]
						s1 = Expected0(p.[sub], curSy)
						s2 = Expected(p.[next], curSy)
						CheckOverlap(s1, s2, 2)
					End If
					CheckAlts(p.[sub])
				ElseIf p.typ = Node.any Then
					If Sets.Elements(p.[set]) = 0 Then
						LL1Error(3, Nothing)
						' e.g. {ANY} ANY or [ANY] ANY or ( ANY | ANY )
					End If
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
		End Sub
		Public Sub CheckLL1()
			For Each sym As Symbol In nonterminals
				curSy = sym
				CheckAlts(curSy.graph)
			Next
		End Sub
		'------------- check if resolvers are legal  -------------------------------
		Private Sub ResErr(ByVal p As Node, ByVal msg As String)
			errors.Warning(p.line, p.pos.col, msg)
		End Sub
		Private Sub CheckRes(ByVal p As Node, ByVal rslvAllowed As Boolean)
			While p IsNot Nothing
				Select Case p.typ
					Case Node.alt
						Dim expected As New BitArray(terminals.Count)
						Dim q As Node = p
						While q IsNot Nothing
							expected.[Or](Expected0(q.[sub], curSy))
							q = q.down
						End While
						Dim soFar As New BitArray(terminals.Count)
						q = p
						While q IsNot Nothing
							If q.[sub].typ = Node.rslv Then
								Dim fs As BitArray = Me.Expected(q.[sub].[next], curSy)
								If Sets.Intersect(fs, soFar) Then
									ResErr(q.[sub], "Warning: Resolver will never be evaluated. " & "Place it at previous conflicting alternative.")
								End If
								If Not Sets.Intersect(fs, expected) Then
									ResErr(q.[sub], "Warning: Misplaced resolver: no LL(1) conflict.")
								End If
							Else
								soFar.[Or](Me.Expected(q.[sub], curSy))
							End If
							CheckRes(q.[sub], True)
							q = q.down
						End While
					Case Node.iter, Node.opt
						If p.[sub].typ = Node.rslv Then
							Dim fs As BitArray = First(p.[sub].[next])
							Dim fsNext As BitArray = Expected(p.[next], curSy)
							If Not Sets.Intersect(fs, fsNext) Then
								ResErr(p.[sub], "Warning: Misplaced resolver: no LL(1) conflict.")
							End If
						End If
						CheckRes(p.[sub], True)
					Case Node.rslv
						If Not rslvAllowed Then
							ResErr(p, "Warning: Misplaced resolver: no alternative.")
						End If
				End Select
				If p.up Then
					Exit While
				End If
				p = p.[next]
				rslvAllowed = False
			End While
		End Sub
		Public Sub CheckResolvers()
			For Each sym As Symbol In nonterminals
				curSy = sym
				CheckRes(curSy.graph, False)
			Next
		End Sub
		'------------- check if every nts has a production -------------------------
		Public Function NtsComplete() As Boolean
			Dim complete As Boolean = True
			For Each sym As Symbol In nonterminals
				If sym.graph Is Nothing Then
					complete = False
					errors.SemErr("  No production for " & sym.name)
				End If
			Next
			Return complete
		End Function
		'-------------- check if every nts can be reached  -------------------------
		Private Sub MarkReachedNts(ByVal p As Node)
			While p IsNot Nothing
				If p.typ = Node.nt AndAlso Not visited(p.sym.n) Then
					' new nt reached
					visited(p.sym.n) = True
					MarkReachedNts(p.sym.graph)
				ElseIf p.typ = Node.alt OrElse p.typ = Node.iter OrElse p.typ = Node.opt Then
					MarkReachedNts(p.[sub])
					If p.typ = Node.alt Then
						MarkReachedNts(p.down)
					End If
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
		End Sub
		Public Function AllNtReached() As Boolean
			Dim ok As Boolean = True
			visited = New BitArray(nonterminals.Count)
			visited(gramSy.n) = True
			MarkReachedNts(gramSy.graph)
			For Each sym As Symbol In nonterminals
				If Not visited(sym.n) Then
					ok = False
					errors.Warning(Space(2) & sym.name & " cannot be reached")
				End If
			Next
			Return ok
		End Function
		'--------- check if every nts can be derived to terminals  -----------------
		Private Function IsTerm(ByVal p As Node, ByVal mark As BitArray) As Boolean
			' true if graph can be derived to terminals
			While p IsNot Nothing
				If p.typ = Node.nt AndAlso Not mark(p.sym.n) Then
					Return False
				End If
				If p.typ = Node.alt AndAlso Not IsTerm(p.[sub], mark) AndAlso (p.down Is Nothing OrElse Not IsTerm(p.down, mark)) Then
					Return False
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
			Return True
		End Function
		Public Function AllNtToTerm() As Boolean
			Dim changed As Boolean
			Dim ok As Boolean = True
			Dim mark As New BitArray(nonterminals.Count)
			' a nonterminal is marked if it can be derived to terminal symbols
			Do
				changed = False
				For Each sym As Symbol In nonterminals
					If Not mark(sym.n) AndAlso IsTerm(sym.graph, mark) Then
						mark(sym.n) = True
						changed = True
					End If
				Next
			Loop While changed
			For Each sym As Symbol In nonterminals
				If Not mark(sym.n) Then
					ok = False
					errors.SemErr(Space(2) & sym.name & " cannot be derived to terminals")
				End If
			Next
			Return ok
		End Function
		'---------------------------------------------------------------------------
		'  Cross reference list
		'---------------------------------------------------------------------------
		Public Sub XRef()
			Dim xref As New SortedList(New SymbolComp())
			' collect lines where symbols have been defined
			For Each sym As Symbol In nonterminals
				Dim list As ArrayList = DirectCast(xref(sym), ArrayList)
				If list Is Nothing Then
					list = New ArrayList()
					xref(sym) = list
				End If
				list.Add(-sym.line)
			Next
			' collect lines where symbols have been referenced
			For Each n As Node In nodes
				If n.typ = Node.t OrElse n.typ = Node.wt OrElse n.typ = Node.nt Then
					Dim list As ArrayList = DirectCast(xref(n.sym), ArrayList)
					If list Is Nothing Then
						list = New ArrayList()
						xref(n.sym) = list
					End If
					list.Add(n.line)
				End If
			Next
			' print cross reference list
			trace.WriteLine()
			trace.WriteLine("Cross reference list:")
			trace.WriteLine("--------------------")
			trace.WriteLine()
			For Each sym As Symbol In xref.Keys
				trace.Write("  {0,-12}", Name(sym.name))
				Dim list As ArrayList = DirectCast(xref(sym), ArrayList)
				Dim col As Integer = 14
				For Each line As Integer In list
					If col + 5 > 80 Then
						trace.WriteLine()
						For col = 1 To 14
							trace.Write(" ")
						Next
					End If
					trace.Write("{0,5}", line)
					col += 5
				Next
				trace.WriteLine()
			Next
			trace.WriteLine()
			trace.WriteLine()
		End Sub
		Public Sub SetDDT(ByVal s As String)
			s = s.ToUpper()
			For Each ch As Char In s
				If "0"C <= ch AndAlso ch <= "9"C Then
					ddt(AscW(ch) - AscW("0"C)) = True
				Else
					Select Case ch
						Case "A"C : ddt(0) = True ' trace automaton
						Case "F"C : ddt(1) = True ' list first/follow sets
						Case "G"C : ddt(2) = True ' print syntax graph
						Case "I"C : ddt(3) = True ' trace computation of first sets
						Case "J"C : ddt(4) = True ' print ANY and SYNC sets
						Case "P"C : ddt(8) = True ' print statistics
						Case "S"C : ddt(6) = True ' list symbol table
						Case "X"C : ddt(7) = True ' list cross reference table
						Case Else
					End Select
				End If
			Next
		End Sub
		Public Sub SetOption(ByVal s As String)
			Dim [option] As String() = Split(s, "=", 2)
			Dim name     As String   = [option](0)
			Dim value    As String   = [option](1)
			If "$namespace".Equals(name) Then
				If nsName Is Nothing Then
					nsName = value
				End If
			ElseIf "$checkEOF".Equals(name) Then
				checkEOF = "True".Equals(value)
			End If
		End Sub
		Class SymbolComp
			Implements IComparer
			Public Function Compare(x As Object, y As Object) As Integer Implements IComparer.Compare
				Return DirectCast(x, Symbol).name.CompareTo(DirectCast(y, Symbol).name)
			End Function
		End Class
	End Class

End Namespace
