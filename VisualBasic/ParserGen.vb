'-------------------------------------------------------------------------------
'ParserGen.vb -- Generation of the Recursive Descent Parser
'Compiler Generator Coco/R,
'Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
'extended by M. Loeberbauer & A. Woess, Univ. of Linz
'with improvements by Pat Terry, Rhodes University
'with token inheritance by Martin Lercher, Singhammer dtSoftware Munich
'
'This program is free software; you can redistribute it and/or modify it
'under the terms of the GNU General Public License as published by the
'Free Software Foundation; either version 2, or (at your option) any
'later version.
'
'This program is distributed in the hope that it will be useful, but
'WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
'or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
'for more details.
'
'You should have received a copy of the GNU General Public License along
'with this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'
'As an exception, it is allowed to write an extension of Coco/R that is
'used as a plugin in non-free software.
'
'If not otherwise stated, any source code generated by Coco/R (other than
'Coco/R itself) does not fall under the GNU General Public License.
'-------------------------------------------------------------------------------
Option Compare Binary
Option Explicit On
Option Strict On

Imports System
Imports System.Collections
Imports System.IO

Namespace at.jku.ssw.Coco

	Public Class ParserGen
		Private Const   maxTerm              As Integer = 3        ' sets of size < maxTerm are enumerated
		Private Const   CR                   As Char    = ChrW(13)
		Private Const   LF                   As Char    = ChrW(10)
		Private Const   EOF                  As Integer = AscW(Char.MinValue) - 1
		' error codes
		Private Const   tErr                 As Integer = 0
		Private Const   altErr               As Integer = 1
		Private Const   syncErr              As Integer = 2
		Public          importPos            As Position           ' "Imports" definitions from the attributed grammar
		Private         errorNr              As Integer            ' highest parser error number
		Private         curSy                As Symbol             ' symbol whose production is currently generated
		Private         fram                 As StreamReader       ' parser frame file
		Private         gen                  As StreamWriter       ' generated parser source file
		Private         err                  As StringWriter       ' generated parser error messages
		Private         symSet               As New ArrayList()
		' other Coco objects
		Private         tab                  As Tab
		Private         trace                As TextWriter
		Private         errors               As Errors
		Private         buffer               As Buffer
		Private         strVbReservedWords() As String = { _
			"AddHandler".ToLower, _
			"AddressOf".ToLower, _
			"Alias".ToLower, _
			"And".ToLower, _
			"AndAlso".ToLower, _
			"As".ToLower, _
			"Boolean".ToLower, _
			"ByRef".ToLower, _
			"Byte".ToLower, _
			"ByVal".ToLower, _
			"Call".ToLower, _
			"Case".ToLower, _
			"Catch".ToLower, _
			"CBool".ToLower, _
			"CByte".ToLower, _
			"CChar".ToLower, _
			"CDate".ToLower, _
			"CDbl".ToLower, _
			"CDec".ToLower, _
			"Char".ToLower, _
			"CInt".ToLower, _
			"Class".ToLower, _
			"CLng".ToLower, _
			"CObj".ToLower, _
			"Const".ToLower, _
			"Continue".ToLower, _
			"CSByte".ToLower, _
			"CShort".ToLower, _
			"CSng".ToLower, _
			"CStr".ToLower, _
			"CType".ToLower, _
			"CUInt".ToLower, _
			"CULng".ToLower, _
			"CUShort".ToLower, _
			"Date".ToLower, _
			"Decimal".ToLower, _
			"Declare".ToLower, _
			"Default".ToLower, _
			"Delegate".ToLower, _
			"Dim".ToLower, _
			"DirectCast".ToLower, _
			"Do".ToLower, _
			"Double".ToLower, _
			"Each".ToLower, _
			"Else".ToLower, _
			"ElseIf".ToLower, _
			"End".ToLower, _
			"EndIf".ToLower, _
			"Enum".ToLower, _
			"Erase".ToLower, _
			"Error".ToLower, _
			"Event".ToLower, _
			"Exit".ToLower, _
			"False".ToLower, _
			"Finally".ToLower, _
			"For".ToLower, _
			"Friend".ToLower, _
			"Function".ToLower, _
			"Get".ToLower, _
			"GetType".ToLower, _
			"Global".ToLower, _
			"GoSub".ToLower, _
			"GoTo".ToLower, _
			"Handles".ToLower, _
			"If".ToLower, _
			"Implements".ToLower, _
			"Imports".ToLower, _
			"In".ToLower, _
			"Inherits".ToLower, _
			"Integer".ToLower, _
			"Interface".ToLower, _
			"Is".ToLower, _
			"IsNot".ToLower, _
			"Let".ToLower, _
			"Lib".ToLower, _
			"Like".ToLower, _
			"Long".ToLower, _
			"Loop".ToLower, _
			"Me".ToLower, _
			"Mod".ToLower, _
			"Module".ToLower, _
			"MustInherit".ToLower, _
			"MustOverride".ToLower, _
			"MyBase".ToLower, _
			"MyClass".ToLower, _
			"Namespace".ToLower, _
			"Narrowing".ToLower, _
			"New".ToLower, _
			"Next".ToLower, _
			"Not".ToLower, _
			"Nothing".ToLower, _
			"NotInheritable".ToLower, _
			"NotOverridable".ToLower, _
			"Object".ToLower, _
			"Of".ToLower, _
			"On".ToLower, _
			"Operator".ToLower, _
			"Option".ToLower, _
			"Optional".ToLower, _
			"Or".ToLower, _
			"OrElse".ToLower, _
			"Overloads".ToLower, _
			"Overridable".ToLower, _
			"Overrides".ToLower, _
			"ParamArray".ToLower, _
			"Partial".ToLower, _
			"Private".ToLower, _
			"Property".ToLower, _
			"Protected".ToLower, _
			"Public".ToLower, _
			"RaiseEvent".ToLower, _
			"ReadOnly".ToLower, _
			"ReDim".ToLower, _
			"REM".ToLower, _
			"RemoveHandler".ToLower, _
			"Resume".ToLower, _
			"Return".ToLower, _
			"SByte".ToLower, _
			"Select".ToLower, _
			"Set".ToLower, _
			"Shadows".ToLower, _
			"Shared".ToLower, _
			"Short".ToLower, _
			"Single".ToLower, _
			"Static".ToLower, _
			"Step".ToLower, _
			"Stop".ToLower, _
			"String".ToLower, _
			"Structure".ToLower, _
			"Sub".ToLower, _
			"SyncLock".ToLower, _
			"Then".ToLower, _
			"Throw".ToLower, _
			"To".ToLower, _
			"True".ToLower, _
			"Try".ToLower, _
			"TryCast".ToLower, _
			"TypeOf".ToLower, _
			"UInteger".ToLower, _
			"ULong".ToLower, _
			"UShort".ToLower, _
			"Using".ToLower, _
			"Variant".ToLower, _
			"Wend".ToLower, _
			"When".ToLower, _
			"While".ToLower, _
			"Widening".ToLower, _
			"With".ToLower, _
			"WithEvents".ToLower, _
			"WriteOnly".ToLower, _
			"Xor".ToLower _
		}
		Private Sub Indent(ByVal n As Integer)
			For i As Integer = 1 To n
				gen.Write(vbTab)
			Next
		End Sub
		Private Function Overlaps(ByVal s1 As BitArray, ByVal s2 As BitArray) As Boolean
			Dim len As Integer = s1.Count
			For i As Integer = 0 To len - 1
				If s1(i) AndAlso s2(i) Then
					Return True
				End If
			Next
			Return False
		End Function
		' use a switch if more than 5 alternatives and none starts with a resolver, and no LL1 warning
		Private Function UseSwitch(ByVal p As Node) As Boolean
			Dim s1 As BitArray
			Dim s2 As BitArray
			If p.typ <> Node.alt Then
				Return False
			End If
			Dim nAlts As Integer = 0
			s1 = New BitArray(tab.terminals.Count)
			While p IsNot Nothing
				s2 = tab.Expected0(p.[sub], curSy)
				' must not optimize with switch statement, if there are ll1 warnings
				If Overlaps(s1, s2) Then
					Return False
				End If
				s1.[Or](s2)
				nAlts += 1
				' must not optimize with switch-statement, if alt uses a resolver expression
				If p.[sub].typ = Node.rslv Then
					Return False
				End If
				p = p.down
			End While
			Return nAlts > 5
		End Function
		Private Sub CopySourcePart(ByVal pos As Position, ByVal indent As Integer, Optional ByVal blnNewLine As Boolean = True)
			' Copy text described by pos from atg to gen
			Dim ch As Integer
			Dim i As Integer
			Dim strLine As String = Nothing
			If pos IsNot Nothing Then
				buffer.Pos = pos.beg
				ch = buffer.Read()
				If tab.emitLines Then
					gen.WriteLine()
					gen.WriteLine("#line {0} ""{1}""", pos.line, tab.srcName)
				End If
				While buffer.Pos <= pos.[end]
					While ch = AscW(CR) OrElse ch = AscW(LF)
						' eol is either CR or CRLF or LF
						If Len(Trim(strLine)) > 0 Then
							gen.Write(StrDup(indent, vbTab) & RTrim(strLine) & vbNewLine)
							strLine = ""
						End If
						' skip CR
						If ch = AscW(CR) Then
							ch = buffer.Read()
						End If
						' skip LF
						If ch = AscW(LF) Then
							ch = buffer.Read()
						End If
						i = 1
						' skip blanks at beginning of line
						While i < pos.col AndAlso (ch = AscW(" "C) OrElse ch = 9)
							ch = buffer.Read()
							i += 1
						End While
						If buffer.Pos > pos.[end] Then
							GoTo done
						End If
					End While
					If ch <> EOF Then strLine &= ChrW(ch) 'gen.Write(ChrW(ch))
					ch = buffer.Read()
				End While
		done:
				If Len(Trim(strLine)) > 0 Then
					gen.Write(StrDup(indent, vbTab) & RTrim(strLine))
					strLine = ""
				End If
				If blnNewLine Then
					gen.WriteLine()
				End If
			End If
		End Sub
		Private Sub GenErrorMsg(ByVal errTyp As Integer, ByVal sym As Symbol)
			errorNr += 1
			err.Write("Case {0,4} : ", errorNr)
			err.Write("s = """)
			Select Case errTyp
				Case tErr
					If sym.name(0) = """"C Then
						err.Write(tab.Escape(sym.name) & " expected")
					Else
						err.Write(sym.name & " expected")
					End If
				Case altErr
					err.Write("invalid " & sym.name)
				Case syncErr
					err.Write("this symbol not expected in " & sym.name)
			End Select
			err.WriteLine("""")
		End Sub
		Private Function NewCondSet(ByVal s As BitArray) As Integer
			For i As Integer = 1 To symSet.Count - 1
				If Sets.Equals(s, DirectCast(symSet(i), BitArray)) Then
					Return i
				End If
			Next
			' skip symSet[0] (reserved for union of SYNC sets)
			symSet.Add(s.Clone())
			Return symSet.Count - 1
		End Function
		Private Sub GenCond(ByVal s As BitArray, ByVal p As Node)
			If p.typ = Node.rslv Then
				CopySourcePart(p.pos, 0, False)
			Else
				Dim n As Integer = Sets.Elements(s)
				If n = 0 Then
					gen.Write("False") ' happens if an ANY set matches no symbol
				ElseIf n <= maxTerm Then
					For Each sym As Symbol In tab.terminals
						If s(sym.n) Then
							gen.Write("isKind(la, {0})", sym.n)
							n -= 1
							If n > 0 Then
								gen.Write(" OrElse ")
							End If
						End If
					Next
				Else
					gen.Write("StartOf({0})", NewCondSet(s))
				End If
			End If
		End Sub
		Private Sub PutCaseLabels(ByVal s0 As BitArray)
			Dim s as BitArray = DerivationsOf(s0)
			Dim n as Integer = 0
			gen.Write("Case ")
			For Each sym As Symbol In tab.terminals
				If s(sym.n) Then
					If n > 0 Then
						gen.Write(", ")
					End If
					gen.Write("{0}", sym.n)
					n += 1
				End If
			Next
			gen.Write(" ' ")
			For Each sym As Symbol In tab.terminals
				If s(sym.n) Then
					If n > 1 Then
						gen.Write("{0}:{1} ", sym.n, sym.name)
					Else
						gen.Write(sym.name)
					End If
				End If
			Next
			gen.WriteLine()
		End Sub		
		Private Function DerivationsOf(ByVal s0 as BitArray) as BitArray
			Dim s as BitArray = DirectCast(s0.Clone(), BitArray)
			Dim done as Boolean = False
			Do Until done
				done = true
				For Each sym as Symbol in tab.terminals
					If s(sym.n) Then
						For Each baseSym as Symbol in tab.terminals
							If baseSym.inherits is sym AndAlso Not s(baseSym.n) Then
								s(baseSym.n) = True
								done = false
							End If
						Next
					End If
				Next
			Loop
			Return s
		End Function
		Private Sub GenCode(ByVal p As Node, ByVal indent As Integer, ByVal isChecked As BitArray)
			Dim p2 As Node
			Dim s1 As BitArray
			Dim s2 As BitArray
			While p IsNot Nothing
				Select Case p.typ
					Case Node.nt
						Me.Indent(indent)
						gen.Write(EscapeVbName(p.sym.name) & "(")
						CopySourcePart(p.pos, 0, False)
						gen.WriteLine(")")
					Case Node.t
						Me.Indent(indent)
						' assert: if isChecked[p.sym.n] is true, then isChecked contains only p.sym.n
						If isChecked(p.sym.n) Then
							gen.WriteLine("[Get]()")
						Else
							gen.WriteLine("Expect({0}) ' {1}", p.sym.n, p.sym.name)
						End If
					Case Node.wt
						Me.Indent(indent)
						s1 = tab.Expected(p.[next], curSy)
						s1.[Or](tab.allSyncSets)
						Dim ncs1 As Integer = NewCondSet(s1)
						Dim ncs1sym as Symbol = DirectCast(tab.terminals(ncs1), Symbol)
						gen.WriteLine("ExpectWeak({0}, {1}) ' {2} followed by {3}", p.sym.n, ncs1, p.sym.name, ncs1sym.name)
					Case Node.any
						Me.Indent(indent)
						Dim acc As Integer = Sets.Elements(p.set)
						If (tab.terminals.Count = (acc + 1) OrElse (acc > 0 AndAlso Sets.Equals(p.set, isChecked))) Then
							' either this ANY accepts any terminal (the + 1 = end of file), or exactly what's allowed here
							gen.WriteLine("[Get]()")
						Else
							GenErrorMsg(altErr, curSy)
							If (acc > 0) Then
								gen.Write("If (")
								GenCond(p.set, p)
								gen.WriteLine(") Then")
								Me.Indent(indent + 1)
								gen.WriteLine(vbTab & "[Get]()")
								Me.Indent(indent)
								gen.WriteLine("Else")
								Me.Indent(indent + 1)
								gen.WriteLine("SynErr({0})", errorNr)
								Me.Indent(indent)
								gen.WriteLine("End If")
							Else
								gen.WriteLine("SynErr({0}) ' ANY node that matches no symbol", errorNr)
							End If
						End If
					Case Node.eps
					Case Node.rslv
					Case Node.sem
						CopySourcePart(p.pos, indent)
					Case Node.sync
						Me.Indent(indent)
						GenErrorMsg(syncErr, curSy)
						s1 = DirectCast(p.[set].Clone(), BitArray)
						gen.Write("While Not (")
						GenCond(s1, p)
						gen.WriteLine(")")
						indent += 1
						Me.Indent(indent)
						gen.WriteLine("SynErr({0})", errorNr)
						Me.Indent(indent)
						gen.WriteLine("[Get]()")
						indent -= 1
						Me.Indent(indent)
						gen.WriteLine("End While")
					Case Node.alt
						s1 = tab.First(p)
						Dim equal As Boolean = Sets.Equals(s1, isChecked)
						Dim useSwitch As Boolean = Me.UseSwitch(p)
						If useSwitch Then
							Me.Indent(indent)
							gen.WriteLine("Select Case la.kind")
							indent += 1
						End If
						p2 = p
						While p2 IsNot Nothing
							s1 = tab.Expected(p2.[sub], curSy)
							Me.Indent(indent)
							If useSwitch Then
								PutCaseLabels(s1)
							ElseIf p2 Is p Then
								gen.Write("If ")
								GenCond(s1, p2.[sub])
								gen.WriteLine(" Then")
							ElseIf p2.down Is Nothing AndAlso equal Then
								gen.WriteLine("Else")
							Else
								gen.Write("ElseIf ")
								GenCond(s1, p2.[sub])
								gen.WriteLine(" Then")
							End If
							GenCode(p2.[sub], indent + 1, s1)
							p2 = p2.down
						End While
						If equal Then
							If useSwitch Then
								indent -= 1
								Me.Indent(indent)
								gen.WriteLine("End Select")
							Else
								Me.Indent(indent)
								gen.WriteLine("End If")
							End If
						Else
							GenErrorMsg(altErr, curSy)
							If useSwitch Then
								Me.Indent(indent)
								gen.WriteLine("Case Else")
								Me.Indent(indent + 1)
								gen.WriteLine("SynErr({0})", errorNr)
								indent -= 1
								Me.Indent(indent)
								gen.WriteLine("End Select")
							Else
								Me.Indent(indent)
								gen.WriteLine("Else")
								Me.Indent(indent + 1)
								gen.WriteLine("SynErr({0})", errorNr)
								Me.Indent(indent)
								gen.WriteLine("End If")
							End If
						End If
					Case Node.iter
						Me.Indent(indent)
						p2 = p.[sub]
						gen.Write("While ")
						If p2.typ = Node.wt Then
							s1 = tab.Expected(p2.[next], curSy)
							s2 = tab.Expected(p.[next], curSy)
							gen.Write("WeakSeparator({0}, {1}, {2})", p2.sym.n, NewCondSet(s1), NewCondSet(s2))
							s1 = New BitArray(tab.terminals.Count)
							' for inner structure
							If p2.up OrElse p2.[next] Is Nothing Then
								p2 = Nothing
							Else
								p2 = p2.[next]
							End If
						Else
							s1 = tab.First(p2)
							GenCond(s1, p2)
						End If
						gen.WriteLine()
						GenCode(p2, indent + 1, s1)
						Me.Indent(indent)
						gen.WriteLine("End While")
					Case Node.opt
						s1 = tab.First(p.[sub])
						Me.Indent(indent)
						gen.Write("If ")
						GenCond(s1, p.[sub])
						gen.WriteLine(" Then")
						GenCode(p.[sub], indent + 1, s1)
						Me.Indent(indent)
						gen.WriteLine("End If")
				End Select
				If p.typ <> Node.eps AndAlso p.typ <> Node.sem AndAlso p.typ <> Node.sync Then
					isChecked.SetAll(False) ' = new BitArray(tab.terminals.Count)
				End If
				If p.up Then
					Exit While
				End If
				p = p.[next]
			End While
		End Sub
		Private Sub GenTokens(ByVal indent As Integer)
			For Each sym As Symbol In tab.terminals
				If [Char].IsLetter(sym.name(0)) Then
					Dim inh as String = String.Empty
					If sym.inherits IsNot Nothing Then inh = "INHERITS " & sym.inherits.name
					gen.WriteLine(StrDup(indent, vbTab) & "Public  Const   _{0,-10} As Integer = {1,2} ' TOKEN {0,-10}{2}", sym.name, sym.n, inh)
				End If
			Next
		End Sub
		Private Sub GenTokenBase(ByVal indent as Integer)
			Dim n as Integer = 0
			For Each sym As Symbol In tab.terminals
				If n Mod 20 = 0 Then 
					Me.Indent(indent)
				Else If n Mod 4 = 0 Then
					gen.Write(" "c)
				End If
				n += 1
				If sym.inherits is Nothing Then
					gen.Write("{0,2}", -1)
				Else
					gen.Write("{0,2}", sym.inherits.n)
				End If
				If n < tab.terminals.Count Then gen.Write(","c)
				If n Mod 20 = 0 Then gen.WriteLine(" _")
			Next
			If n Mod 20 = 0 Then Return
			gen.WriteLine(" _")			
		End Sub
		Private Sub GenPragmas(ByVal indent As Integer)
			For Each sym As Symbol In tab.pragmas
				gen.WriteLine(StrDup(indent, vbTab) & "Public  Const   _{0,-10} As Integer = {1,2}", sym.name, sym.n)
			Next
		End Sub
		Private Sub GenCodePragmas(ByVal indent As Integer)
			For Each sym As Symbol In tab.pragmas
				gen.WriteLine(StrDup(indent, vbTab) & "If la.kind = {0} Then", sym.n)
				CopySourcePart(sym.semPos, indent + 1)
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
			Next
		End Sub
		Private Sub GenProductions(ByVal indent As Integer)
			For Each sym As Symbol In tab.nonterminals
				curSy = sym
				gen.Write(StrDup(indent, vbTab) & "Private Sub {0}(", EscapeVbName(sym.name))
				CopySourcePart(sym.attrPos, 0, False)
				gen.WriteLine(")")
				CopySourcePart(sym.semPos, indent + 1)
				GenCode(sym.graph, indent + 1, New BitArray(tab.terminals.Count))
				gen.WriteLine(StrDup(indent, vbTab) & "End Sub")
			Next
		End Sub
		Private Sub InitSets0(ByVal indent As Integer)
			For i As Integer = 0 To symSet.Count - 1
				Dim s As BitArray = DirectCast(symSet(i), BitArray)
				gen.Write(StrDup(indent, vbTab) & "{")
				Dim j As Integer = 0
				For Each sym As Symbol In tab.terminals
					If s(sym.n) Then
						gen.Write("_T,")
					Else
						gen.Write("_x,")
					End If
					j += 1
					If j Mod 4 = 0 Then
						gen.Write(" ")
					End If
				Next
				' now write an elephant at the last position to not fiddle with the commas:
				If i = symSet.Count - 1 Then
					gen.WriteLine("_x} _")
				Else
					gen.WriteLine("_x}, _")
				End If
			Next
		End Sub
		Private Sub InitSets(ByVal indent As Integer)
			For i As Integer = 0 To symSet.Count - 1
				Dim s As BitArray = DerivationsOf(DirectCast(symSet(i), BitArray))
				gen.Write(StrDup(indent, vbTab) & "{")
				Dim j As Integer = 0
				For Each sym As Symbol In tab.terminals
					If s(sym.n) Then
						gen.Write("_T,")
					Else
						gen.Write("_x,")
					End If
					j += 1
					If j Mod 4 = 0 Then
						gen.Write(" ")
					End If
				Next
				' now write an elephant at the last position to not fiddle with the commas:
				If i = symSet.Count - 1 Then
					gen.WriteLine("_x} _")
				Else
					gen.WriteLine("_x}, _")
				End If
			Next
		End Sub
		Public Sub WriteParser()
			Dim g      As Generator = New Generator(tab)
			Dim oldPos As Integer   = buffer.Pos ' Pos is modified by CopySourcePart
			Dim indent As Integer   = 0
			symSet.Add(tab.allSyncSets)
			err = New StringWriter()
			For Each sym As Symbol In tab.terminals
				GenErrorMsg(tErr, sym)
			Next
			gen = g.OpenGen("Parser.vb")
			g.GenCopyright()
			fram = g.OpenFrame("Parser.frame")
			g.SkipFramePart("-->begin", indent)
			g.CopyFramePart("-->namespace", indent)
			If importPos IsNot Nothing Then
				CopySourcePart(importPos, indent)
			End If
			' AW open namespace, if it exists
			If tab.nsName IsNot Nothing AndAlso tab.nsName.Length > 0 Then
				gen.WriteLine("Namespace {0}", tab.nsName)
				indent += 1
			End If
			g.CopyFramePart("-->constants", indent)
			indent += 1
			GenTokens(indent)
			' ML 2002/09/07 write the token kinds
			gen.WriteLine(StrDup(indent, vbTab) & "Public  Const   {0,-11} As Integer = {1,2}", "maxT", tab.terminals.Count - 1)
			GenPragmas(indent)
			indent -= 1
			' ML 2005/09/23 write the pragma kinds
			g.CopyFramePart("-->declarations", indent)
			CopySourcePart(tab.semDeclPos, indent + 1, False)
			g.CopyFramePart("-->pragmas", indent)
			GenCodePragmas(indent + 3)
			g.CopyFramePart("-->productions", indent)
			GenProductions(indent + 1)
			g.CopyFramePart("-->parseRoot", indent)
			gen.WriteLine(StrDup(indent + 2, vbTab) & "{0}()", tab.gramSy.name)
			g.CopyFramePart("-->tbase", indent)
			GenTokenBase(indent + 2)
			g.CopyFramePart("-->initialization0", indent)
			InitSets0(indent + 2)
			g.CopyFramePart("-->initialization", indent)
			InitSets(indent + 2)
			g.CopyFramePart("-->errors", indent)
			Dim sr As StringReader = New StringReader(err.ToString())
			Dim sl As String = sr.ReadLine()
			Do Until sl Is Nothing
				gen.WriteLine(StrDup(indent + 3, vbTab) & sl)
				sl = sr.ReadLine()
			Loop
			g.CopyFramePart("$$$", indent)
			' AW 2002-12-20 close namespace, if it exists
			If tab.nsName IsNot Nothing AndAlso tab.nsName.Length > 0 Then
				indent -= 1
				gen.WriteLine()
				gen.WriteLine("End Namespace")
			End If
			gen.Close()
			buffer.Pos = oldPos
		End Sub
		Public Sub WriteStatistics()
			trace.WriteLine()
			trace.WriteLine("{0,4} terminals", tab.terminals.Count)
			trace.WriteLine("{0,4} symbols", tab.terminals.Count + tab.pragmas.Count + tab.nonterminals.Count)
			trace.WriteLine("{0,4} nodes", tab.nodes.Count)
			trace.WriteLine("{0,4} sets", symSet.Count)
		End Sub
		Public Sub New(ByVal parser As Parser)
			tab = parser.tab
			errors = parser.errors
			trace = parser.trace
			buffer = parser.scanner.buffer
			errorNr = -1
			importPos = Nothing
			Array.Sort(strVbReservedWords)
		End Sub
		Private Function EscapeVbName(ByVal strName As String) As String
			Dim intIndex As Integer = -1
			intIndex = Array.BinarySearch(strVbReservedWords, strName.ToLower)
			If (intIndex < 0) Then
				Return strName
			Else
				Return "[" & strName & "]"
			End If
		End Function
	End Class

End Namespace
