'-------------------------------------------------------------------------------
'Compiler Generator Coco/R,
'Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
'extended by M. Loeberbauer & A. Woess, Univ. of Linz
'with improvements by Pat Terry, Rhodes University
'with token inheritance by Martin Lercher, Singhammer dtSoftware Munich
'
'This program is free software; you can redistribute it and/or modify it
'under the terms of the GNU General Public License as published by the
'Free Software Foundation; either version 2, or (at your option) any
'later version.
'
'This program is distributed in the hope that it will be useful, but
'WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
'or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
'for more details.
'
'You should have received a copy of the GNU General Public License along
'with this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'
'As an exception, it is allowed to write an extension of Coco/R that is
'used as a plugin in non-free software.
'
'If not otherwise stated, any source code generated by Coco/R (other than
'Coco/R itself) does not fall under the GNU General Public License.
'-------------------------------------------------------------------------------
-->begin
Option Compare Binary
Option Explicit On
Option Strict On

Imports System
Imports System.IO

-->namespace

Public Class Parser
-->constants
	Private Const   _T        As Boolean = True
	Private Const   _x        As Boolean = False
	Private Const   minErrDist  As Integer =  2
	Public          scanner     As Scanner
	Public          errors      As Errors
	Public          t           As Token                ' last recognized token
	Public          la          As Token                ' lookahead token
	Private         errDist     As Integer = minErrDist
-->declarations
	Public Sub New(ByVal scanner As Scanner)
		Me.scanner = scanner
		errors = New Errors()
	End Sub
	Private Sub SynErr(ByVal n As Integer)
		If errDist >= minErrDist Then
			errors.SynErr(la.line, la.col, n)
		End If
		errDist = 0
	End Sub
	Public Sub SemErr(ByVal msg As String)
		If errDist >= minErrDist Then
			errors.SemErr(t.line, t.col, msg)
		End If
		errDist = 0
	End Sub
	Private Sub [Get]()
		While True
			t = la
			la = scanner.Scan()
			If la.kind <= maxT Then
				errDist += 1
				Exit While
			End If
-->pragmas
			la = t
		End While
	End Sub
	Private Function isKind(ByVal t as Token, ByVal n as Integer) as Boolean
		Dim k as Integer = t.kind
		Do While k >= 0
			If k = n Then Return True
			k = tBase(k)
		Loop
		Return False
	End Function
	Private Sub Expect(ByVal n As Integer)
		If isKind(la, n) Then
			[Get]()
		Else
			SynErr(n)
		End If
	End Sub
	' is the lookahead token la a start of the production s?
	Private Function StartOf(ByVal s As Integer) As Boolean
		Return blnSet(s, la.kind)
	End Function
	Private Sub ExpectWeak(ByVal n As Integer, ByVal follow As Integer)
		If isKind(la, n) Then
			[Get]()
		Else
			SynErr(n)
			While Not StartOf(follow)
				[Get]()
			End While
		End If
	End Sub
	Private Function WeakSeparator(ByVal n As Integer, ByVal syFol As Integer, ByVal repFol As Integer) As Boolean
		Dim kind As Integer = la.kind
		If isKind(la, n) Then
			[Get]()
			Return True
		ElseIf StartOf(repFol) Then
			Return False
		Else
			SynErr(n)
			While Not (blnSet(syFol, kind) OrElse blnSet(repFol, kind) OrElse blnSet(0, kind))
				[Get]()
				kind = la.kind
			End While
			Return StartOf(syFol)
		End If
	End Function
-->productions
	Public Sub Parse()
		la = New Token()
		la.val = ""
		[Get]()
-->parseRoot
	End Sub
	' a token's base type
	Private Shared ReadOnly tBase() as Integer = { _
-->tbase
	}
	' states that a particular production (1st index) can start with a particular token (2nd index)
	Private Shared ReadOnly blnSet0(,) As Boolean = { _
-->initialization0
	}
	' as blnSet0 but with token inheritance taken into account
	Private Shared ReadOnly blnSet(,) As Boolean = { _
-->initialization
	}
End Class

Public Class Errors
	Public count        As Integer                                 ' number of errors detected
	Public errorStream  As TextWriter = Console.Out                ' error messages go to this stream
	Public errMsgFormat As String     = "-- line {0} col {1}: {2}" ' 0=line, 1=column, 2=text
	Public Overridable Sub SynErr(ByVal line As Integer, ByVal col As Integer, ByVal n As Integer)
		Dim s As String
		Select Case n
-->errors
			Case Else : s = "error " & n
		End Select
		errorStream.WriteLine(errMsgFormat, line, col, s)
		count += 1
	End Sub
	Public Overridable Sub SemErr(ByVal line As Integer, ByVal col As Integer, ByVal s As String)
		errorStream.WriteLine(errMsgFormat, line, col, s)
		count += 1
	End Sub
	Public Overridable Sub SemErr(ByVal s As String)
		errorStream.WriteLine(s)
		count += 1
	End Sub
	Public Overridable Sub Warning(ByVal line As Integer, ByVal col As Integer, ByVal s As String)
		errorStream.WriteLine(errMsgFormat, line, col, s)
	End Sub
	Public Overridable Sub Warning(ByVal s As String)
		errorStream.WriteLine(s)
	End Sub
End Class

Public Class FatalError
	Inherits Exception
	Public Sub New(ByVal m As String)
		MyBase.New(m)
	End Sub
End Class
$$$
