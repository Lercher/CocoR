'-------------------------------------------------------------------------------
'Compiler Generator Coco/R,
'Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
'extended by M. Loeberbauer & A. Woess, Univ. of Linz
'with improvements by Pat Terry, Rhodes University
'
'This program is free software; you can redistribute it and/or modify it
'under the terms of the GNU General Public License as published by the
'Free Software Foundation; either version 2, or (at your option) any
'later version.
'
'This program is distributed in the hope that it will be useful, but
'WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
'or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
'for more details.
'
'You should have received a copy of the GNU General Public License along
'with this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'
'As an exception, it is allowed to write an extension of Coco/R that is
'used as a plugin in non-free software.
'
'If not otherwise stated, any source code generated by Coco/R (other than
'Coco/R itself) does not fall under the GNU General Public License.
'-------------------------------------------------------------------------------
-->begin
Option Compare Binary
Option Explicit On
Option Strict On

Imports System
Imports System.Collections.Generic
Imports System.IO

-->namespace

Public Class Token
	Public kind    As Integer ' token kind
	Public pos     As Integer ' token position in bytes      in the source text (starting at 0)
	Public charPos As Integer ' token position in characters in the source text (starting at 0)
	Public col     As Integer ' token column (starting at 1)
	Public line    As Integer ' token line   (starting at 1)
	Public val     As String  ' token value
	Public [next]  As Token   ' ML 2005-03-11 Tokens are kept in linked list
End Class

Public Class Buffer
	' This Buffer supports the following cases:
	' 1) seekable stream (file)
	'    a) whole stream in buffer
	'    b) part of stream in buffer
	' 2) non seekable stream (network, console)
	Public  Const EOF               As Integer = AscW(Char.MinValue) - 1
	Private Const MIN_BUFFER_LENGTH As Integer = 1024                   '  1KB
	Private Const MAX_BUFFER_LENGTH As Integer = MIN_BUFFER_LENGTH * 64 ' 64KB
	Private       buf               As Byte()                           ' input buffer
	Private       bufStart          As Integer                          ' position of first byte in buffer relative to input stream
	Private       bufLen            As Integer                          ' length of buffer
	Private       fileLen           As Integer                          ' length of input stream (may change if the stream is no file)
	Private       bufPos            As Integer                          ' current position in buffer
	Private       stream            As Stream                           ' input stream (seekable)
	Private       isUserStream      As Boolean                          ' was the stream opened by the user?
	Public Sub New(ByVal s As Stream, ByVal isUserStream As Boolean)
		stream = s
		Me.isUserStream = isUserStream
		If stream.CanSeek Then
			fileLen  = CInt(stream.Length)
			bufLen   = Math.Min(fileLen, MAX_BUFFER_LENGTH)
			bufStart = Int32.MaxValue ' nothing in the buffer so far
		Else
			bufStart = 0
			bufLen   = 0
			fileLen  = 0
		End If
		If bufLen > 0 Then
			buf = New Byte(bufLen - 1) {}
		Else
			buf = New Byte(MIN_BUFFER_LENGTH - 1) {}
		End If
		If fileLen > 0 Then
			Pos = 0    ' setup buffer to position 0 (start)
		Else
			bufPos = 0 ' index 0 is already after the file, thus Pos = 0 is invalid
		End If
		If bufLen = fileLen AndAlso stream.CanSeek Then
			Close()
		End If
	End Sub
	Protected Sub New(ByVal b As Buffer) ' called in UTF8Buffer constructor
		buf = b.buf
		bufStart = b.bufStart
		bufLen = b.bufLen
		fileLen = b.fileLen
		bufPos = b.bufPos
		stream = b.stream
		' keep destructor from closing the stream
		b.stream = Nothing
		isUserStream = b.isUserStream
	End Sub
	Protected Overrides Sub Finalize()
		Try
			Close()
		Finally
			MyBase.Finalize()
		End Try
	End Sub
	Protected Sub Close()
		If Not isUserStream AndAlso stream IsNot Nothing Then
			stream.Close()
			stream = Nothing
		End If
	End Sub
	Public Overridable Function Read() As Integer
		Dim intReturn As Integer
		If bufPos < bufLen Then
			intReturn = buf(bufPos)
			bufPos += 1
		ElseIf Pos < fileLen Then
			Pos = Pos ' shift buffer start to Pos
			intReturn = buf(bufPos)
			bufPos += 1
		ElseIf stream IsNot Nothing AndAlso Not stream.CanSeek AndAlso ReadNextStreamChunk() > 0 Then
			intReturn = buf(bufPos)
			bufPos += 1
		Else
			intReturn = EOF
		End If
		Return intReturn
	End Function
	Public Function Peek() As Integer
		Dim curPos As Integer = Pos
		Dim ch As Integer = Read()
		Pos = curPos
		Return ch
	End Function
	' beg .. begin, zero-based, inclusive, in byte
	' end .. end,   zero-based, exclusive, in byte
	Public Function GetString(ByVal beg As Integer, ByVal [end] As Integer) As String
		Dim len As Integer = 0
		Dim buf As Char() = New Char([end] - beg) {}
		Dim oldPos As Integer = Pos
		Pos = beg
		While Pos < [end]
			Dim ch As Integer = Read()
			buf(len) = ChrW(ch)
			len += 1
		End While
		Pos = oldPos
		Return New String(buf, 0, len)
	End Function
	Public Property Pos() As Integer
		Get
			Return bufPos + bufStart
		End Get
		Set
			If value >= fileLen AndAlso stream IsNot Nothing AndAlso Not stream.CanSeek Then
				' Wanted position is after buffer and the stream
				' is not seek-able e.g. network or console,
				' thus we have to read the stream manually till
				' the wanted position is in sight.
				While value >= fileLen AndAlso ReadNextStreamChunk() > 0
				End While
			End If
			If value < 0 OrElse value > fileLen Then
				Throw New FatalError([String].Format("buffer out of bounds access, position: {0}", value))
			End If
			If value >= bufStart AndAlso value < bufStart + bufLen Then ' already in buffer
				bufPos = value - bufStart
			ElseIf stream IsNot Nothing Then ' must be swapped in
				stream.Seek(value, SeekOrigin.Begin)
				bufLen = stream.Read(buf, 0, buf.Length)
				bufStart = value
				bufPos = 0
			Else
				' set the position to the end of the file, Pos will return fileLen.
				bufPos = fileLen - bufStart
			End If
		End Set
	End Property
	' Read the next chunk of bytes from the stream, increases the buffer
	' if needed and updates the fields fileLen and bufLen.
	' Returns the number of bytes read.
	Private Function ReadNextStreamChunk() As Integer
		Dim free As Integer = buf.Length - bufLen
		If free = 0 Then
			' in the case of a growing input stream
			' we can neither seek in the stream, nor can we
			' foresee the maximum length, thus we must adapt
			' the buffer size on demand.
			Dim newBuf As Byte() = New Byte(bufLen * 2 - 1) {}
			Array.Copy(buf, newBuf, bufLen)
			buf = newBuf
			free = bufLen
		End If
		Dim read As Integer = stream.Read(buf, bufLen, free)
		If read > 0 Then
			bufLen += read
			fileLen = bufLen
			Return read
		End If
		' end of stream reached
		Return 0
	End Function
End Class

Public Class UTF8Buffer
	Inherits Buffer
	Public Sub New(ByVal b As Buffer)
		MyBase.New(b)
	End Sub
	Public Overloads Overrides Function Read() As Integer
		Dim ch As Integer
		Do
			' until we find a utf8 start (0xxxxxxx or 11xxxxxx)
			ch = MyBase.Read()
		Loop While (ch >= 128) AndAlso ((ch And 192) <> 192) AndAlso (ch <> EOF)
		If ch < 128 OrElse ch = EOF Then
			' nothing to do, first 127 chars are the same in ascii and utf8
			' 0xxxxxxx or end of file character
		ElseIf (ch And 240) = 240 Then
			' 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
			Dim c1 As Integer = ch And 7
			ch = MyBase.Read()
			Dim c2 As Integer = ch And 63
			ch = MyBase.Read()
			Dim c3 As Integer = ch And 63
			ch = MyBase.Read()
			Dim c4 As Integer = ch And 63
			ch = (((((c1 << 6) Or c2) << 6) Or c3) << 6) Or c4
		ElseIf (ch And 224) = 224 Then
			' 1110xxxx 10xxxxxx 10xxxxxx
			Dim c1 As Integer = ch And 15
			ch = MyBase.Read()
			Dim c2 As Integer = ch And 63
			ch = MyBase.Read()
			Dim c3 As Integer = ch And 63
			ch = (((c1 << 6) Or c2) << 6) Or c3
		ElseIf (ch And 192) = 192 Then
			' 110xxxxx 10xxxxxx
			Dim c1 As Integer = ch And 31
			ch = MyBase.Read()
			Dim c2 As Integer = ch And 63
			ch = (c1 << 6) Or c2
		End If
		Return ch
	End Function
End Class

Public Class Scanner
	Private Const           EOL     As Char      = ChrW(10)
	Private Const           eofSym  As Integer   =  0                  ' pdt
-->declarations
	Public                  buffer  As Buffer                          ' scanner buffer
	Private                 t       As Token                           ' current token
	Private                 ch      As Integer                         ' current input character
	Private                 pos     As Integer                         ' byte position of current character
	Private                 charPos As Integer                         ' position by unicode characters starting with 0
	Private                 col     As Integer                         ' column number of current character
	Private                 line    As Integer                         ' line number of current character
	Private                 oldEols As Integer                         ' EOLs that appeared in a comment
	Private Shared ReadOnly start   As Dictionary(Of Integer, Integer) ' maps first token character to start state
	Private                 tokens  As Token                           ' list of tokens already peeked (first token is a dummy)
	Private                 pt      As Token                           ' current peek token
	Private                 tval()  As Char      = New Char(128) {}    ' text of current token
	Private                 tlen    As Integer                         ' length of current token
	Shared Sub New()
		start = New Dictionary(Of Integer, Integer)(128)
-->initialization
	End Sub
	Public Sub New(ByVal fileName As String)
		Try
			Dim stream As Stream = New FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)
			buffer = New Buffer(stream, False)
			Init()
		Catch generatedExceptionName As IOException
			Throw New FatalError("Cannot open file " & fileName)
		End Try
	End Sub
	Public Sub New(ByVal s As Stream)
		buffer = New Buffer(s, True)
		Init()
	End Sub
	Private Sub Init()
		pos     = -1
		line    =  1
		col     =  0
		charPos = -1
		oldEols =  0
		NextCh()
		If ch = 239 Then
			' check optional byte order mark for UTF-8
			NextCh()
			Dim ch1 As Integer = ch
			NextCh()
			Dim ch2 As Integer = ch
			If ch1 <> 187 OrElse ch2 <> 191 Then
				Throw New FatalError([String].Format("illegal byte order mark: EF {0,2:X} {1,2:X}", ch1, ch2))
			End If
			buffer  = New UTF8Buffer(buffer)
			col     =  0
			charPos = -1
			NextCh()
		End If
		tokens = New Token()
		pt = tokens ' first token is a dummy
	End Sub
	Private Sub NextCh()
		If oldEols > 0 Then
			ch = AscW(EOL)
			oldEols -= 1
		Else
			pos = buffer.Pos
			' buffer reads unicode chars, if UTF8 has been detected
			ch  = buffer.Read()
			col     += 1
			charPos += 1
			' replace isolated '\r' by '\n' in order to make
			' eol handling uniform across Windows, Unix and Mac
			If ch = 13 AndAlso buffer.Peek() <> 10 Then
				ch = AscW(EOL)
			End If
			If ch = AscW(EOL) Then
				line += 1
				col = 0
			End If
		End If
-->casing1
	End Sub
	Private Sub AddCh()
		If tlen >= tval.Length Then
			Dim newBuf() As Char = New Char(2 * tval.Length) {}
			Array.Copy(tval, 0, newBuf, 0, tval.Length)
			tval = newBuf
		End If
		If ch <> Buffer.EOF Then
-->casing2
			NextCh()
		End If
	End Sub
-->comments
	Private Sub CheckLiteral()
-->literals
	End Sub
	Private Function NextToken() As Token
		While ch = AscW(" "C) OrElse _
-->scan1
			NextCh()
		End While
-->scan2
		Dim recKind As Integer = noSym
		Dim recEnd  As Integer = pos
		t = New Token()
		t.pos     = pos
		t.col     = col
		t.line    = line
		t.charPos = charPos
		Dim state As Integer
		If start.ContainsKey(ch) Then
			state = CType(start(ch), Integer)
		Else
			state = 0
		End If
		tlen = 0
		AddCh()
		Select Case state
			Case -1 ' NextCh already done
				t.kind = eofSym
			Case 0  ' NextCh already done
			Case_0:
				If recKind <> noSym Then
					tlen = recEnd - t.pos
					SetScannerBehindT()
				End If
				t.kind = recKind
-->scan3
		End Select
		t.val = New String(tval, 0, tlen)
		Return t
	End Function
	Private Sub SetScannerBehindT()
		buffer.Pos = t.pos
		NextCh()
		line = t.line
		col = t.col
		For i As Integer = 0 To tlen - 1
			NextCh()
		Next
	End Sub
	' get the next token (possibly a token already seen during peeking)
	Public Function Scan() As Token
		If tokens.[next] Is Nothing Then
			Return NextToken()
		Else
			tokens = tokens.[next]
			pt = tokens
			Return tokens
		End If
	End Function
	' peek for the next token, ignore pragmas
	Public Function Peek() As Token
		Do
			If pt.[next] Is Nothing Then
				pt.[next] = NextToken()
			End If
			pt = pt.[next]
		Loop While pt.kind > maxT ' skip pragmas
		Return pt
	End Function
	' make sure that peeking starts at the current scan position
	Public Sub ResetPeek()
		pt = tokens
	End Sub
End Class
$$$
