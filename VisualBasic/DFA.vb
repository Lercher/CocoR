'-------------------------------------------------------------------------------
'DFA.vb -- Generation of the Scanner Automaton
'Compiler Generator Coco/R,
'Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
'extended by M. Loeberbauer & A. Woess, Univ. of Linz
'with improvements by Pat Terry, Rhodes University
'
'This program is free software; you can redistribute it and/or modify it
'under the terms of the GNU General Public License as published by the
'Free Software Foundation; either version 2, or (at your option) any
'later version.
'
'This program is distributed in the hope that it will be useful, but
'WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
'or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
'for more details.
'
'You should have received a copy of the GNU General Public License along
'with this program; if not, write to the Free Software Foundation, Inc.,
'59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
'
'As an exception, it is allowed to write an extension of Coco/R that is
'used as a plugin in non-free software.
'
'If not otherwise stated, any source code generated by Coco/R (other than
'Coco/R itself) does not fall under the GNU General Public License.
'-------------------------------------------------------------------------------
Option Compare Binary
Option Explicit On
Option Strict On

Imports System
Imports System.Collections
Imports System.IO
Imports System.Text

Namespace at.jku.ssw.Coco

	Public Class State                ' state of finite automaton
		Public nr          As Integer ' state number
		Public firstAction As Action  ' to first action of this state
		Public endOf       As Symbol  ' recognized token if state is final
		Public ctx         As Boolean ' true if state is reached via contextTrans
		Public [next]      As State
		Public Sub AddAction(ByVal act As Action)
			Dim lasta As Action = Nothing
			Dim a As Action = firstAction
			While a IsNot Nothing AndAlso act.typ >= a.typ
				lasta = a
				a = a.[next]
			End While
			' collecting classes at the beginning gives better performance
			act.[next] = a
			If a Is firstAction Then
				firstAction = act
			Else
				lasta.[next] = act
			End If
		End Sub
		Public Sub DetachAction(ByVal act As Action)
			Dim lasta As Action = Nothing
			Dim a As Action = firstAction
			While a IsNot Nothing AndAlso a IsNot act
				lasta = a
				a = a.[next]
			End While
			If a IsNot Nothing Then
				If a Is firstAction Then
					firstAction = a.[next]
				Else
					lasta.[next] = a.[next]
				End If
			End If
		End Sub
		Public Sub MeltWith(ByVal s As State)
			' copy actions of s to state
			Dim action As Action = s.firstAction
			While action IsNot Nothing
				Dim a As New Action(action.typ, action.sym, action.tc)
				a.AddTargets(action)
				AddAction(a)
				action = action.[next]
			End While
		End Sub
	End Class

	Public Class Action          ' action of finite automaton
		Public typ    As Integer ' type of action symbol: clas, chr
		Public sym    As Integer ' action symbol
		Public tc     As Integer ' transition code: normalTrans, contextTrans
		Public target As Target  ' states reached from this action
		Public [next] As Action
		Public Sub New(ByVal typ As Integer, ByVal sym As Integer, ByVal tc As Integer)
			Me.typ = typ
			Me.sym = sym
			Me.tc = tc
		End Sub
		Public Sub AddTarget(ByVal t As Target)
			' add t to the action.targets
			Dim last As Target = Nothing
			Dim p As Target = target
			While p IsNot Nothing AndAlso t.state.nr >= p.state.nr
				If t.state Is p.state Then
					Return
				End If
				last = p
				p = p.[next]
			End While
			t.[next] = p
			If p Is target Then
				target = t
			Else
				last.[next] = t
			End If
		End Sub
		Public Sub AddTargets(ByVal a As Action)
			' add copy of a.targets to action.targets
			Dim p As Target = a.target
			While p IsNot Nothing
				Dim t As New Target(p.state)
				AddTarget(t)
				p = p.[next]
			End While
			If a.tc = Node.contextTrans Then
				tc = Node.contextTrans
			End If
		End Sub
		Public Function Symbols(ByVal tab As Tab) As CharSet
			Dim s As CharSet
			If typ = Node.clas Then
				s = tab.CharClassSet(sym).Clone()
			Else
				s = New CharSet()
				s.[Set](sym)
			End If
			Return s
		End Function
		Public Sub ShiftWith(ByVal s As CharSet, ByVal tab As Tab)
			If s.Elements() = 1 Then
				typ = Node.chr
				sym = s.First()
			Else
				Dim c As CharClass = tab.FindCharClass(s)
				If c Is Nothing Then
					c = tab.NewCharClass("#", s)
				End If
				' class with dummy name
				typ = Node.clas
				sym = c.n
			End If
		End Sub
	End Class

	Public Class Target       ' set of states that are reached by an action
		Public state As State ' target state
		Public [next] As Target
		Public Sub New(ByVal s As State)
			state = s
		End Sub
	End Class

	Public Class Melted           ' info about melted states
		Public [set]  As BitArray ' set of old states
		Public state  As State    ' new state
		Public [next] As Melted
		Public Sub New(ByVal [set] As BitArray, ByVal state As State)
			Me.[set] = [set]
			Me.state = state
		End Sub
	End Class

	Public Class Comment ' info about comment syntax
		Public start  As String
		Public [stop] As String
		Public nested As Boolean
		Public [next] As Comment
		Public Sub New(ByVal start As String, ByVal [stop] As String, ByVal nested As Boolean)
			Me.start = start
			Me.[stop] = [stop]
			Me.nested = nested
		End Sub
	End Class

	Public Class CharSet
		Public Class Range
			Public from As Integer
			Public [to] As Integer
			Public [next] As Range
			Public Sub New(ByVal from As Integer, ByVal [to] As Integer)
				Me.from = from
				Me.[to] = [to]
			End Sub
		End Class
		Public head As Range
		Public Default ReadOnly Property Item(ByVal i As Integer) As Boolean
			Get
				Dim p As Range = head
				While p IsNot Nothing
					If i < p.from Then
						Return False
					ElseIf i <= p.[to] Then ' p.from <= i <= p.to
						Return True
					End If
					p = p.[next]
				End While
				Return False
			End Get
		End Property
		Public Sub [Set](ByVal i As Integer)
			Dim cur As Range = head
			Dim prev As Range = Nothing
			While cur IsNot Nothing AndAlso i >= cur.from - 1
				If i <= cur.[to] + 1 Then ' (cur.from-1) <= i <= (cur.to+1)
					If i = cur.from - 1 Then
						cur.from -= 1
					ElseIf i = cur.[to] + 1 Then
						Dim [next] As Range = cur.[next]
						cur.[to] += 1
						If [next] IsNot Nothing AndAlso cur.[to] = [next].from - 1 Then
							cur.[to] = [next].[to]
							cur.[next] = [next].[next]
						End If
					End If
					Return
				End If
				prev = cur
				cur = cur.[next]
			End While
			Dim n As New Range(i, i)
			n.[next] = cur
			If prev Is Nothing Then
				head = n
			Else
				prev.[next] = n
			End If
		End Sub
		Public Function Clone() As CharSet
			Dim s As New CharSet()
			Dim prev As Range = Nothing
			Dim cur As Range = head
			While cur IsNot Nothing
				Dim r As New Range(cur.from, cur.[to])
				If prev Is Nothing Then
					s.head = r
				Else
					prev.[next] = r
				End If
				prev = r
				cur = cur.[next]
			End While
			Return s
		End Function
		Public Shadows Function Equals(ByVal s As CharSet) As Boolean
			Dim p As Range = head
			Dim q As Range = s.head
			While p IsNot Nothing AndAlso q IsNot Nothing
				If p.from <> q.from OrElse p.[to] <> q.[to] Then
					Return False
				End If
				p = p.[next]
				q = q.[next]
			End While
			Return p Is q
		End Function
		Public Function Elements() As Integer
			Dim n As Integer = 0
			Dim p As Range = head
			While p IsNot Nothing
				n += p.[to] - p.from + 1
				p = p.[next]
			End While
			Return n
		End Function
		Public Function First() As Integer
			If head IsNot Nothing Then
				Return head.from
			End If
			Return -1
		End Function
		Public Sub [Or](ByVal s As CharSet)
			Dim p As Range = s.head
			While p IsNot Nothing
				For i As Integer = p.from To p.[to]
					[Set](i)
				Next
				p = p.[next]
			End While
		End Sub
		Public Sub [And](ByVal s As CharSet)
			Dim x As New CharSet()
			Dim p As Range = head
			While p IsNot Nothing
				For i As Integer = p.from To p.[to]
					If s(i) Then
						x.[Set](i)
					End If
				Next
				p = p.[next]
			End While
			head = x.head
		End Sub
		Public Sub Subtract(ByVal s As CharSet)
			Dim x As New CharSet()
			Dim p As Range = head
			While p IsNot Nothing
				For i As Integer = p.from To p.[to]
					If Not s(i) Then
						x.[Set](i)
					End If
				Next
				p = p.[next]
			End While
			head = x.head
		End Sub
		Public Function Includes(ByVal s As CharSet) As Boolean
			Dim p As Range = s.head
			While p IsNot Nothing
				For i As Integer = p.from To p.[to]
					If Not Me(i) Then
						Return False
					End If
				Next
				p = p.[next]
			End While
			Return True
		End Function
		Public Function Intersects(ByVal s As CharSet) As Boolean
			Dim p As Range = s.head
			While p IsNot Nothing
				For i As Integer = p.from To p.[to]
					If Me(i) Then
						Return True
					End If
				Next
				p = p.[next]
			End While
			Return False
		End Function
		Public Sub Fill()
			head = New Range(AscW([Char].MinValue), AscW([Char].MaxValue))
		End Sub
	End Class

	Class Generator
		Private Const    EOF        As Integer = AscW(Char.MinValue) - 1
		Private          fram       As StreamReader
		Private          gen        As StreamWriter
		Private ReadOnly tab        As Tab
		Private          frameFile  As String
		Private          restOfLine As String
		Public Sub New(ByVal tab As Tab)
			Me.tab = tab
		End Sub
		Public Function OpenFrame(ByVal source As String) As StreamReader
			Dim sr As StreamReader
			Dim fn As String = Nothing
			If tab.frameDir IsNot Nothing Then
				fn = Path.Combine(tab.frameDir, source)
			End If
			If fn Is Nothing Or Not File.Exists(fn) Then
				fn = Path.Combine(tab.srcDir, source)
			End If
			If fn Is Nothing Or Not File.Exists(fn) Then
				Throw New FatalError("Cannot find : " & source)
			End If
			Try
				sr        = New StreamReader(fn)
				frameFile = fn
				fram      = sr
			Catch generatedExceptionName As FileNotFoundException
				Throw New FatalError("Cannot open source file:" & fn)
			End Try
			OpenFrame = sr
		End Function
		Public Function OpenGen(ByVal target As String) As StreamWriter
			Dim sw As StreamWriter
			Dim fn As String = Path.Combine(tab.outDir, target)
			Try
				If File.Exists(fn) Then
					File.Copy(fn, fn & ".old", True)
				End If
				sw  = New StreamWriter(fn) ' pdt
				gen = sw
			Catch generatedExceptionName As IOException
				Throw New FatalError("Cannot generate file: " & fn)
			End Try
			OpenGen = sw
		End Function
		Public Sub GenCopyright()
			OpenFrame("Copyright.frame")
			CopyFramePart("$$$", 0)
		End Sub
		Public Sub SkipFramePart(ByVal [stop] As String, ByVal indent As Integer)
			CopyFramePart([stop], False, indent)
		End Sub
		Public Sub CopyFramePart(ByVal [stop] As String, ByVal indent As Integer)
			CopyFramePart([stop], True, indent)
		End Sub
		Private Sub CopyFramePart(ByVal [stop] As String, ByVal generateOutput As Boolean, ByVal indent As Integer)
			Dim spos As Integer
			If Len(restOfLine) > 0 Then
				gen.WriteLine(restOfLine)
				restOfLine = ""
			End If
			While True
				Dim strLine As String = fram.ReadLine()
				If strLine Is Nothing Then
					Exit While
				End If
				spos = InStr(strLine, [stop])
				If spos > 0 Then
					If Len([stop]) = Len(strLine) Then
						Return
					Else
						restOfLine = Mid(strLine, spos + Len([stop]))
						If generateOutput Then
							strLine = Left(strLine, spos - 1)
							If Len(strLine) > 0 Then
								gen.Write(StrDup(indent, vbTab) & strLine)
							End If
						End If
					End If
				Else
					If generateOutput Then
						If Len(strLine) > 0 Then
							gen.WriteLine(StrDup(indent, vbTab) & strLine)
						Else
							gen.WriteLine()
						End If
					End If
				End If
			End While
			'Throw New FatalError("Incomplete or corrupt frame file: " & frameFile)
		End Sub
	End Class

	Public Class DFA
		Private       maxStates    As Integer
		Private       lastStateNr  As Integer      ' highest state number
		Private       firstState   As State
		Private       lastState    As State        ' last allocated state
		Private       lastSimState As Integer      ' last non melted state
		Private       fram         As StreamReader ' scanner frame input
		Private       gen          As StreamWriter ' generated scanner file
		Private       curSy        As Symbol       ' current token to be recognized (in FindTrans)
		Private       curGraph     As Node         ' start of graph for current token (in FindTrans)
		Private       dirtyDFA     As Boolean      ' DFA may become nondeterministic in MatchLiteral
		Public        ignoreCase   As Boolean      ' true if input should be treated case-insensitively
		Public        hasCtxMoves  As Boolean      ' DFA has context transitions
		' other Coco objects
		Private       parser       As Parser
		Private       tab          As Tab
		Private       errors       As Errors
		Private       trace        As TextWriter
		'---------- Output primitives
		Private Function Ch(ByVal intChar As Integer) As String
			If intChar = AscW(Char.MaxValue) Then
				Return "AscW(Char.MaxValue)"
			ElseIf intChar < AscW(" "C) OrElse intChar >= 127 OrElse intChar = AscW("'"C) OrElse intChar = AscW("\"C) Then
				Return Convert.ToString(intChar)
			ElseIf intChar = AscW(""""C)
				Return "AscW(""""""""C)"
			Else
				Return [String].Format("AscW(""{0}""C)", ChrW(intChar))
			End If
		End Function
		Private Function ChCond(ByVal ch As Char) As String
			Return [String].Format("ch = {0}", Me.Ch(AscW(ch)))
		End Function
		Private Sub PutRange(ByVal s As CharSet)
			Dim r As CharSet.Range = s.head
			While r IsNot Nothing
				If r.from = r.[to] Then
					gen.Write(ChCond(ChrW(r.from)))
				ElseIf r.from = 0 Then
					gen.Write("ch <= " & Ch(r.[to]))
				Else
					gen.Write("ch >= " & Ch(r.from) & " AndAlso ch <= " & Ch(r.[to]))
				End If
				If r.[next] IsNot Nothing Then
					gen.Write(" OrElse ")
				End If
				r = r.[next]
			End While
		End Sub
		'---------- State handling
		Private Function NewState() As State
			Dim s As New State()
			lastStateNr += 1
			s.nr = lastStateNr
			If firstState Is Nothing Then
				firstState = s
			Else
				lastState.[next] = s
			End If
			lastState = s
			Return s
		End Function
		Private Sub NewTransition(ByVal from As State, ByVal [to] As State, ByVal typ As Integer, ByVal sym As Integer, ByVal tc As Integer)
			Dim t As New Target([to])
			Dim a As New Action(typ, sym, tc)
			a.target = t
			from.AddAction(a)
			If typ = Node.clas Then
				curSy.tokenKind = Symbol.classToken
			End If
		End Sub
		Private Sub CombineShifts()
			Dim state As State
			Dim a As Action
			Dim b As Action
			Dim c As Action
			Dim seta As CharSet
			Dim setb As CharSet
			state = firstState
			While state IsNot Nothing
				a = state.firstAction
				While a IsNot Nothing
					b = a.[next]
					While b IsNot Nothing
						If a.target.state Is b.target.state AndAlso a.tc = b.tc Then
							seta = a.Symbols(tab)
							setb = b.Symbols(tab)
							seta.[Or](setb)
							a.ShiftWith(seta, tab)
							c = b
							b = b.[next]
							state.DetachAction(c)
						Else
							b = b.[next]
						End If
					End While
					a = a.[next]
				End While
				state = state.[next]
			End While
		End Sub
		Private Sub FindUsedStates(ByVal state As State, ByVal used As BitArray)
			Dim a As Action = state.firstAction
			If used(state.nr) Then
				Return
			End If
			used(state.nr) = True
			While a IsNot Nothing
				FindUsedStates(a.target.state, used)
				a = a.[next]
			End While
		End Sub
		Private Sub DeleteRedundantStates()
			Dim newState() As State = New State(lastStateNr + 1) {}
			Dim used As New BitArray(lastStateNr + 1)
			FindUsedStates(firstState, used)
			' combine equal final states
			Dim s1 As State = firstState.[next]
			While s1 IsNot Nothing
				If used(s1.nr) AndAlso s1.endOf IsNot Nothing AndAlso s1.firstAction Is Nothing AndAlso Not s1.ctx Then
					' firstState cannot be final
					Dim s2 As State = s1.[next]
					While s2 IsNot Nothing
						If used(s2.nr) AndAlso s1.endOf Is s2.endOf AndAlso s2.firstAction Is Nothing And Not s2.ctx Then
							used(s2.nr) = False
							newState(s2.nr) = s1
						End If
						s2 = s2.[next]
					End While
				End If
				s1 = s1.[next]
			End While
			Dim state As State = firstState
			While state IsNot Nothing
				If used(state.nr) Then
					Dim a As Action = state.firstAction
					While a IsNot Nothing
						If Not used(a.target.state.nr) Then
							a.target.state = newState(a.target.state.nr)
						End If
						a = a.[next]
					End While
				End If
				state = state.[next]
			End While
			' delete unused states
			lastState = firstState
			lastStateNr = 0
			' firstState has number 0
			state = firstState.[next]
			While state IsNot Nothing
				If used(state.nr) Then
					lastStateNr += 1
					state.nr = lastStateNr
					lastState = state
				Else
					lastState.[next] = state.[next]
				End If
				state = state.[next]
			End While
		End Sub
		Private Function TheState(ByVal p As Node) As State
			Dim state As State
			If p Is Nothing Then
				state = NewState()
				state.endOf = curSy
				Return state
			Else
				Return p.state
			End If
		End Function
		Private Sub [Step](ByVal from As State, ByVal p As Node, ByVal stepped As BitArray)
			If p Is Nothing Then
				Return
			End If
			stepped(p.n) = True
			Select Case p.typ
				Case Node.clas, Node.chr
					NewTransition(from, TheState(p.[next]), p.typ, p.val, p.code)
				Case Node.alt
					[Step](from, p.[sub], stepped)
					[Step](from, p.down, stepped)
				Case Node.iter
					If Tab.DelSubGraph(p.sub) Then
						parser.SemErr("contents of {...} must not be deletable")
					Else
						If p.[next] IsNot Nothing AndAlso Not stepped(p.[next].n) Then
							[Step](from, p.[next], stepped)
						End If
						[Step](from, p.[sub], stepped)
						If p.state IsNot from Then
							[Step](p.state, p, New BitArray(tab.nodes.Count))
						End If
					End If
				Case Node.opt
					If p.[next] IsNot Nothing AndAlso Not stepped(p.[next].n) Then
						[Step](from, p.[next], stepped)
					End If
					[Step](from, p.[sub], stepped)
			End Select
		End Sub
		' Assigns a state n.state to every node n. There will be a transition from
		' n.state to n.next.state triggered by n.val. All nodes in an alternative
		' chain are represented by the same state.
		' Numbering scheme:
		'  - any node after a chr, clas, opt, or alt, must get a new number
		'  - if a nested structure starts with an iteration the iter node must get a new number
		'  - if an iteration follows an iteration, it must get a new number
		Private Sub NumberNodes(ByVal p As Node, ByVal state As State, ByVal renumIter As Boolean)
			If p Is Nothing Then
				Return
			End If
			If p.state IsNot Nothing Then
				Return ' already visited
			End If
			If state Is Nothing OrElse (p.typ = Node.iter AndAlso renumIter) Then
				state = NewState()
			End If
			p.state = state
			If Tab.DelGraph(p) Then
				state.endOf = curSy
			End If
			Select Case p.typ
				Case Node.clas, Node.chr
					NumberNodes(p.[next], Nothing, False)
				Case Node.opt
					NumberNodes(p.[next], Nothing, False)
					NumberNodes(p.[sub], state, True)
				Case Node.iter
					NumberNodes(p.[next], state, True)
					NumberNodes(p.[sub], state, True)
				Case Node.alt
					NumberNodes(p.[next], Nothing, False)
					NumberNodes(p.[sub], state, True)
					NumberNodes(p.down, state, renumIter)
			End Select
		End Sub
		Private Sub FindTrans(ByVal p As Node, ByVal start As Boolean, ByVal marked As BitArray)
			If p Is Nothing OrElse marked(p.n) Then
				Return
			End If
			marked(p.n) = True
			If start Then
				[Step](p.state, p, New BitArray(tab.nodes.Count))
			End If
			' start of group of equally numbered nodes
			Select Case p.typ
				Case Node.clas, Node.chr
					FindTrans(p.[next], True, marked)
				Case Node.opt
					FindTrans(p.[next], True, marked)
					FindTrans(p.[sub], False, marked)
				Case Node.iter
					FindTrans(p.[next], False, marked)
					FindTrans(p.[sub], False, marked)
				Case Node.alt
					FindTrans(p.[sub], False, marked)
					FindTrans(p.down, False, marked)
			End Select
		End Sub
		Public Sub ConvertToStates(ByVal p As Node, ByVal sym As Symbol)
			curSy = sym
			If Tab.DelGraph(p) Then
				parser.SemErr("token might be empty")
			Else
				NumberNodes(p, firstState, True)
				FindTrans(p, True, New BitArray(tab.nodes.Count))
				If (p.typ = Node.iter) Then
					[Step](firstState, p, New BitArray(tab.nodes.Count))
				End If
			End If
		End Sub
		' match string against current automaton, store it either as a fixedToken or as a litToken
		Public Sub MatchLiteral(ByVal s As String, ByVal sym As Symbol)
			s = tab.Unescape(s.Substring(1, s.Length - 2))
			Dim i As Integer
			Dim len As Integer = s.Length
			Dim state As State = firstState
			Dim a As Action = Nothing
			For i = 0 To len - 1
				' try to match s against existing DFA
				a = FindAction(state, s(i))
				If a Is Nothing Then
					Exit For
				End If
				state = a.target.state
			Next
			' if s was not totally consumed or leads to a non-final state => make new DFA from it
			If i <> len OrElse state.endOf Is Nothing Then
				state = firstState
				i = 0
				a = Nothing
				dirtyDFA = True
			End If
			While i < len
				' make new DFA for s[i..len-1], ML: i is either 0 or len
				Dim [to] As State = NewState()
				NewTransition(state, [to], Node.chr, AscW(s(i)), Node.normalTrans)
				state = [to]
				i += 1
			End While
			Dim matchedSym As Symbol = state.endOf
			If state.endOf Is Nothing Then
				state.endOf = sym
			ElseIf matchedSym.tokenKind = Symbol.fixedToken OrElse (a IsNot Nothing AndAlso a.tc = Node.contextTrans) Then
				' s matched a token with a fixed definition or a token with an appendix that will be cut off
				parser.SemErr("tokens " & sym.name & " and " & matchedSym.name & " cannot be distinguished")
			Else
				' matchedSym == classToken || classLitToken
				matchedSym.tokenKind = Symbol.classLitToken
				sym.tokenKind = Symbol.litToken
			End If
		End Sub
		Private Sub SplitActions(ByVal state As State, ByVal a As Action, ByVal b As Action)
			Dim c As Action
			Dim seta As CharSet
			Dim setb As CharSet
			Dim setc As CharSet
			seta = a.Symbols(tab)
			setb = b.Symbols(tab)
			If seta.Equals(setb) Then
				a.AddTargets(b)
				state.DetachAction(b)
			ElseIf seta.Includes(setb) Then
				setc = seta.Clone()
				setc.Subtract(setb)
				b.AddTargets(a)
				a.ShiftWith(setc, tab)
			ElseIf setb.Includes(seta) Then
				setc = setb.Clone()
				setc.Subtract(seta)
				a.AddTargets(b)
				b.ShiftWith(setc, tab)
			Else
				setc = seta.Clone()
				setc.[And](setb)
				seta.Subtract(setc)
				setb.Subtract(setc)
				a.ShiftWith(seta, tab)
				b.ShiftWith(setb, tab)
				c = New Action(0, 0, Node.normalTrans)
				' typ and sym are set in ShiftWith
				c.AddTargets(a)
				c.AddTargets(b)
				c.ShiftWith(setc, tab)
				state.AddAction(c)
			End If
		End Sub
		Private Function Overlap(ByVal a As Action, ByVal b As Action) As Boolean
			Dim seta As CharSet
			Dim setb As CharSet
			If a.typ = Node.chr Then
				If b.typ = Node.chr Then
					Return a.sym = b.sym
				Else
					setb = tab.CharClassSet(b.sym)
					Return setb(a.sym)
				End If
			Else
				seta = tab.CharClassSet(a.sym)
				If b.typ = Node.chr Then
					Return seta(b.sym)
				Else
					setb = tab.CharClassSet(b.sym)
					Return seta.Intersects(setb)
				End If
			End If
		End Function
		Private Sub MakeUnique(ByVal state As State)
			Dim changed As Boolean
			Do
				changed = False
				Dim a As Action = state.firstAction
				While a IsNot Nothing
					Dim b As Action = a.[next]
					While b IsNot Nothing
						If Overlap(a, b) Then
							SplitActions(state, a, b)
							changed = True
						End If
						b = b.[next]
					End While
					a = a.[next]
				End While
			Loop While changed
		End Sub
		Private Sub MeltStates(ByVal state As State)
			Dim ctx As Boolean
			Dim targets As BitArray = Nothing
			Dim endOf As Symbol = Nothing
			Dim action As Action = state.firstAction
			While action IsNot Nothing
				If action.target.[next] IsNot Nothing Then
					GetTargetStates(action, targets, endOf, ctx)
					Dim melt As Melted = StateWithSet(targets)
					If melt Is Nothing Then
						Dim s As State = NewState()
						s.endOf = endOf
						s.ctx = ctx
						Dim targ As Target = action.target
						While targ IsNot Nothing
							s.MeltWith(targ.state)
							targ = targ.[next]
						End While
						MakeUnique(s)
						melt = NewMelted(targets, s)
					End If
					action.target.[next] = Nothing
					action.target.state = melt.state
				End If
				action = action.[next]
			End While
		End Sub
		Private Sub FindCtxStates()
			Dim state As State = firstState
			While state IsNot Nothing
				Dim a As Action = state.firstAction
				While a IsNot Nothing
					If a.tc = Node.contextTrans Then
						a.target.state.ctx = True
					End If
					a = a.[next]
				End While
				state = state.[next]
			End While
		End Sub
		Public Sub MakeDeterministic()
			Dim state As State
			lastSimState = lastState.nr
			maxStates = 2 * lastSimState
			' heuristic for set size in Melted.set
			FindCtxStates()
			state = firstState
			While state IsNot Nothing
				MakeUnique(state)
				state = state.[next]
			End While
			state = firstState
			While state IsNot Nothing
				MeltStates(state)
				state = state.[next]
			End While
			DeleteRedundantStates()
			CombineShifts()
		End Sub
		Public Sub PrintStates()
			Dim state As State = firstState
			trace.WriteLine()
			trace.WriteLine("---------- states ----------")
			While state IsNot Nothing
				Dim first As Boolean = True
				If state.endOf Is Nothing Then
					trace.Write(Space(15))
				Else
					trace.Write("E({0,12})", tab.Name(state.endOf.name))
				End If
				trace.Write("{0,3}:", state.nr)
				If state.firstAction Is Nothing Then
					trace.WriteLine()
				End If
				Dim action As Action = state.firstAction
				While action IsNot Nothing
					If first Then
						trace.Write(" ")
						first = False
					Else
						trace.Write(Space(20))
					End If
					If action.typ = Node.clas Then
						trace.Write("{0,12}", (DirectCast(tab.classes(action.sym), CharClass)).name)
					Else
						trace.Write("{0,12}", """" & ChrW(action.sym) & """")
					End If
					Dim targ As Target = action.target
					While targ IsNot Nothing
						trace.Write(" {0, 3}", targ.state.nr)
						targ = targ.[next]
					End While
					If action.tc = Node.contextTrans Then
						trace.WriteLine(" context")
					Else
						trace.WriteLine()
					End If
					action = action.[next]
				End While
				state = state.[next]
			End While
			trace.WriteLine()
			trace.WriteLine("---------- character classes ----------")
			tab.WriteCharClasses()
		End Sub
		'---------------------------- actions --------------------------------------
		Public Function FindAction(ByVal state As State, ByVal ch As Char) As Action
			Dim a As Action = state.firstAction
			While a IsNot Nothing
				If a.typ = Node.chr AndAlso ch = ChrW(a.sym) Then
					Return a
				ElseIf a.typ = Node.clas Then
					Dim s As CharSet = tab.CharClassSet(a.sym)
					If s(AscW(ch)) Then
						Return a
					End If
				End If
				a = a.[next]
			End While
			Return Nothing
		End Function
		Public Sub GetTargetStates(ByVal a As Action, ByRef targets As BitArray, ByRef endOf As Symbol, ByRef ctx As Boolean)
			' compute the set of target states
			Dim t As Target = a.target
			targets = New BitArray(maxStates)
			endOf = Nothing
			ctx = False
			While t IsNot Nothing
				Dim stateNr As Integer = t.state.nr
				If stateNr <= lastSimState Then
					targets(stateNr) = True
				Else
					targets.[Or](MeltedSet(stateNr))
				End If
				If t.state.endOf IsNot Nothing Then
					If endOf Is Nothing OrElse endOf Is t.state.endOf Then
						endOf = t.state.endOf
					Else
						errors.SemErr("Tokens " & endOf.name & " and " & t.state.endOf.name & " cannot be distinguished")
					End If
				End If
				If t.state.ctx Then
					ctx = True
				End If
				t = t.[next]
			End While
		End Sub
		'------------------------- melted states -----------------------------------
		Private firstMelted As Melted ' head of melted state list
		Private Function NewMelted(ByVal [set] As BitArray, ByVal state As State) As Melted
			Dim m As New Melted([set], state)
			m.[next] = firstMelted
			firstMelted = m
			Return m
		End Function
		Private Function MeltedSet(ByVal nr As Integer) As BitArray
			Dim m As Melted = firstMelted
			While m IsNot Nothing
				If m.state.nr = nr Then
					Return m.[set]
				Else
					m = m.[next]
				End If
			End While
			Throw New FatalError("compiler error in Melted.Set")
		End Function
		Private Function StateWithSet(ByVal s As BitArray) As Melted
			Dim m As Melted = firstMelted
			While m IsNot Nothing
				If Sets.Equals(s, m.[set]) Then
					Return m
				End If
				m = m.[next]
			End While
			Return Nothing
		End Function
		'------------------------ comments -----------------------------------------
		Public firstComment As Comment ' list of comments
		Private Function CommentStr(ByVal p As Node) As String
			Dim s As New StringBuilder()
			While p IsNot Nothing
				If p.typ = Node.chr Then
					s.Append(ChrW(p.val))
				ElseIf p.typ = Node.clas Then
					Dim [set] As CharSet = tab.CharClassSet(p.val)
					If [set].Elements() <> 1 Then
						parser.SemErr("character set contains more than 1 character")
					End If
					s.Append(ChrW([set].First()))
				Else
					parser.SemErr("comment delimiters may not be structured")
				End If
				p = p.[next]
			End While
			If s.Length = 0 OrElse s.Length > 2 Then
				parser.SemErr("comment delimiters must be 1 or 2 characters long")
				s = New StringBuilder("?")
			End If
			Return s.ToString()
		End Function
		Public Sub NewComment(ByVal from As Node, ByVal [to] As Node, ByVal nested As Boolean)
			Dim c As New Comment(CommentStr(from), CommentStr([to]), nested)
			c.[next] = firstComment
			firstComment = c
		End Sub
		'------------------------ scanner generation -------------------------------
		Private Sub GenComBody(ByVal com As Comment, ByVal indent As Integer)
			gen.WriteLine(StrDup(indent, vbTab) & "While True")
			indent += 1
			gen.WriteLine(StrDup(indent, vbTab) & "If {0} Then", ChCond(com.[stop](0)))
			indent += 1
			If com.[stop].Length = 1 Then
				gen.WriteLine(StrDup(indent, vbTab) & "level -= 1")
				gen.WriteLine(StrDup(indent, vbTab) & "If level = 0 Then")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "oldEols = line - line0")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "Return True")
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
			Else
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent, vbTab) & "If {0} Then", ChCond(com.[stop](1)))
				gen.WriteLine(StrDup(indent + 1, vbTab) & "level -= 1")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "If level = 0 Then")
				gen.WriteLine(StrDup(indent + 2, vbTab) & "oldEols = line - line0")
				gen.WriteLine(StrDup(indent + 2, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent + 2, vbTab) & "Return True")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "End If")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
			End If
			indent -= 1
			If com.nested Then
				gen.WriteLine(StrDup(indent, vbTab) & "ElseIf {0} Then", ChCond(com.start(0)))
				indent += 1
				If com.start.Length = 1 Then
					gen.WriteLine(StrDup(indent, vbTab) & "level += 1")
					gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				Else
					gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
					gen.WriteLine(StrDup(indent, vbTab) & "If {0} Then", ChCond(com.start(1)))
					gen.WriteLine(StrDup(indent + 1, vbTab) & "level += 1")
					gen.WriteLine(StrDup(indent + 1, vbTab) & "NextCh()")
					gen.WriteLine(StrDup(indent, vbTab) & "End If")
				End If
				indent -= 1
			End If
			gen.WriteLine(StrDup(indent, vbTab) & "ElseIf ch = Buffer.EOF Then")
			gen.WriteLine(StrDup(indent + 1, vbTab) & "Return False")
			gen.WriteLine(StrDup(indent, vbTab) & "Else")
			gen.WriteLine(StrDup(indent + 1, vbTab) & "NextCh()")
			gen.WriteLine(StrDup(indent, vbTab) & "End If")
			indent -= 1
			gen.WriteLine(StrDup(indent, vbTab) & "End While")
		End Sub
		Private Sub GenComment(ByVal com As Comment, ByVal i As Integer, ByVal indent As Integer)
			gen.WriteLine(StrDup(indent, vbTab) & "Private Function Comment{0}() As Boolean", i)
			indent += 1
			gen.WriteLine(StrDup(indent, vbTab) & "Dim level    As Integer = 1")
			gen.WriteLine(StrDup(indent, vbTab) & "Dim pos0     As Integer = pos")
			gen.WriteLine(StrDup(indent, vbTab) & "Dim line0    As Integer = line")
			gen.WriteLine(StrDup(indent, vbTab) & "Dim col0     As Integer = col")
			gen.WriteLine(StrDup(indent, vbTab) & "Dim charPos0 As Integer = charPos")
			If com.start.Length = 1 Then
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				GenComBody(com, indent)
			Else
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent, vbTab) & "If {0} Then", ChCond(com.start(1)))
				indent += 1
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				GenComBody(com, indent)
				gen.WriteLine(StrDup(indent - 1, vbTab) & "Else")
				gen.WriteLine(StrDup(indent, vbTab) & "buffer.Pos = pos0")
				gen.WriteLine(StrDup(indent, vbTab) & "NextCh()")
				gen.WriteLine(StrDup(indent, vbTab) & "line       = line0")
				gen.WriteLine(StrDup(indent, vbTab) & "col        = col0")
				gen.WriteLine(StrDup(indent, vbTab) & "charPos    = charPos0")
				indent -= 1
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
				gen.WriteLine(StrDup(indent, vbTab) & "Return False")
			End If
			indent -= 1
			gen.WriteLine(StrDup(indent, vbTab) & "End Function")
		End Sub
		Private Function SymName(ByVal sym As Symbol) As String
			If [Char].IsLetter(sym.name(0)) Then
				' real name value is stored in Tab.literals
				For Each e As DictionaryEntry In tab.literals
					If DirectCast(e.Value, Symbol) Is sym Then
						Return DirectCast(e.Key, String)
					End If
				Next
			End If
			Return sym.name
		End Function
		Private Sub GenLiterals(ByVal indent As Integer)
			If ignoreCase Then
				gen.WriteLine(StrDup(indent, vbTab) & "Select Case t.val.ToLower()")
			Else
				gen.WriteLine(StrDup(indent, vbTab) & "Select Case t.val")
			End If
			For Each ts As IList In New IList() { tab.terminals, tab.pragmas }
				For Each sym As Symbol In ts
					If sym.tokenKind = Symbol.litToken Then
						Dim name As String = SymName(sym)
						If ignoreCase Then
							name = name.ToLower()
						End If
						' sym.name stores literals with quotes, e.g. "\"Literal\""
						gen.WriteLine(StrDup(indent + 1, vbTab) & "Case {0,-15} : t.kind = {1,2}", Name, sym.n)
					End If
				Next
			Next
			gen.WriteLine(StrDup(indent + 1, vbTab) & "Case Else")
			gen.WriteLine(StrDup(indent, vbTab) & "End Select")
		End Sub
		Private Sub WriteState(ByVal state As State, ByVal indent As Integer)
			Dim endOf As Symbol = state.endOf
			Dim ctxEnd As Boolean = state.ctx
			Dim action As Action = state.firstAction
			gen.WriteLine(StrDup(indent, vbTab) & "Case {0}", state.nr)
			gen.WriteLine(StrDup(indent, vbTab) & "Case_{0}:", state.nr)
			indent += 1
			If (endOf IsNot Nothing AndAlso state.firstAction IsNot Nothing) Then
				gen.WriteLine(StrDup(indent, vbTab) & "recEnd = pos")
				gen.WriteLine(StrDup(indent, vbTab) & "recKind = {0}", endOf.n)
			End If
			While action IsNot Nothing
				If action Is state.firstAction Then
					gen.Write(StrDup(indent, vbTab) & "If ")
				Else
					gen.Write(StrDup(indent, vbTab) & "ElseIf ")
				End If
				If action.typ = Node.chr Then
					gen.Write(ChCond(ChrW(action.sym)))
				Else
					PutRange(tab.CharClassSet(action.sym))
				End If
				gen.WriteLine(" Then")
				indent += 1
				If action.tc = Node.contextTrans Then
					gen.WriteLine(StrDup(indent, vbTab) & "apx += 1")
					ctxEnd = False
				ElseIf state.ctx Then
					gen.WriteLine(StrDup(indent, vbTab) & "apx = 0")
				End If
				gen.WriteLine(StrDup(indent, vbTab) & "AddCh()")
				gen.WriteLine(StrDup(indent, vbTab) & "GoTo Case_{0}", action.target.state.nr)
				action = action.[next]
				indent -= 1
			End While
			If state.firstAction IsNot Nothing Then
				gen.WriteLine(StrDup(indent, vbTab) & "Else")
				indent += 1
			End If
			If ctxEnd Then
				' final context state: cut appendix
				gen.WriteLine(StrDup(indent, vbTab) & "tlen -= apx")
				gen.WriteLine(StrDup(indent, vbTab) & "SetScannerBehindT()")
			End If
			If endOf Is Nothing Then
				gen.WriteLine(StrDup(indent, vbTab) & "GoTo Case_0")
			Else
				gen.WriteLine(StrDup(indent, vbTab) & "t.kind = {0}", endOf.n)
				If endOf.tokenKind = Symbol.classLitToken Then
					gen.WriteLine(StrDup(indent, vbTab) & "t.val = New String(tval, 0, tlen)")
					gen.WriteLine(StrDup(indent, vbTab) & "CheckLiteral()")
					gen.WriteLine(StrDup(indent, vbTab) & "Return t")
				End If
			End If
			If state.firstAction IsNot Nothing Then
				indent -= 1
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
			End If
		End Sub
		Private Sub WriteStartTab(ByVal indent As Integer)
			Dim action As Action = firstState.firstAction
			While action IsNot Nothing
				Dim targetState As Integer = action.target.state.nr
				If action.typ = Node.chr Then
					gen.WriteLine(StrDup(indent, vbTab) & "start({0,10}) = {1,4}", action.sym, targetState)
				Else
					Dim s As CharSet = tab.CharClassSet(action.sym)
					Dim r As CharSet.Range = s.head
					While r IsNot Nothing
						gen.WriteLine(StrDup(indent, vbTab) & "For i As Integer = {0,4} To {1,4}", r.from, r.[to])
						gen.WriteLine(StrDup(indent + 1, vbTab) & "start(i) = {0,4}", targetState)
						gen.WriteLine(StrDup(indent, vbTab) & "Next")
						r = r.[next]
					End While
				End If
				action = action.[next]
			End While
			gen.WriteLine(StrDup(indent, vbTab) & "start(Buffer.EOF) =   -1")
		End Sub
		Public Sub WriteScanner()
			Dim g      As Generator = New Generator(tab)
			Dim indent As Integer = 0
			If dirtyDFA Then
				MakeDeterministic()
			End If
			gen  = g.OpenGen("Scanner.vb")
			g.GenCopyright()
			fram = g.OpenFrame("Scanner.frame")
			g.SkipFramePart("-->begin", indent)
			g.CopyFramePart("-->namespace", indent)
			If tab.nsName IsNot Nothing AndAlso tab.nsName.Length > 0 Then
				gen.WriteLine("Namespace {0}", tab.nsName)
				indent += 1
			End If
			g.CopyFramePart("-->declarations", indent)
			indent += 1
			gen.WriteLine(StrDup(indent, vbTab) & "Private Const           maxT    As Integer   = {0,2}", tab.terminals.Count - 1)
			gen.WriteLine(StrDup(indent, vbTab) & "Private Const           noSym   As Integer   = {0,2}", tab.noSym.n)
			If ignoreCase Then
				gen.WriteLine(StrDup(indent, vbTab) & "Private                 valCh   As Char                            ' current input character (for token.val)")
			End If
			indent -= 1
			g.CopyFramePart("-->initialization", indent)
			WriteStartTab(indent + 2)
			g.CopyFramePart("-->casing1", indent)
			indent += 2
			If ignoreCase Then
				gen.WriteLine(StrDup(indent, vbTab) & "If ch <> Buffer.EOF Then")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "valCh = ChrW(ch)")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "ch = AscW(Char.ToLower(ChrW(ch)))")
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
			End If
			g.CopyFramePart("-->casing2", indent - 2)
			gen.WriteLine(StrDup(indent + 1, vbTab) & "tval(tlen) = {0}", IIf(ignoreCase, "valCh", "ChrW(ch)"))
			gen.WriteLine(StrDup(indent + 1, vbTab) & "tlen += 1")
			indent -= 2
			g.CopyFramePart("-->comments", indent)
			Dim com As Comment = firstComment
			Dim comIdx As Integer = 0
			While com IsNot Nothing
				GenComment(com, comIdx, indent + 1)
				com = com.[next]
				comIdx += 1
			End While
			g.CopyFramePart("-->literals", indent)
			GenLiterals(indent + 2)
			g.CopyFramePart("-->scan1", indent)
			gen.Write(StrDup(indent + 3, vbTab))
			If tab.ignored.Elements() > 0 Then
				PutRange(tab.ignored)
			Else
				gen.Write("False")
			End If
			gen.WriteLine()
			g.CopyFramePart("-->scan2", indent)
			indent += 2
			If firstComment IsNot Nothing Then
				gen.Write(StrDup(indent, vbTab) & "If ")
				com = firstComment
				comIdx = 0
				While com IsNot Nothing
					gen.Write(ChCond(com.start(0)))
					gen.Write(" AndAlso Comment{0}()", comIdx)
					If com.[next] IsNot Nothing Then
						gen.Write(" OrElse ")
					End If
					com = com.[next]
					comIdx += 1
				End While
				gen.WriteLine(" Then")
				gen.WriteLine(StrDup(indent + 1, vbTab) & "Return NextToken()")
				gen.WriteLine(StrDup(indent, vbTab) & "End If")
			End If
			' pdt
			If hasCtxMoves Then
				gen.WriteLine()
				gen.WriteLine(StrDup(indent, vbTab) & "Dim apx As Integer = 0")
			End If
			indent -= 2
			g.CopyFramePart("-->scan3", indent)
			Dim state As State = firstState.[next]
			While state IsNot Nothing
				WriteState(state, indent + 3)
				state = state.[next]
			End While
			g.CopyFramePart("$$$", indent)
			If tab.nsName IsNot Nothing AndAlso tab.nsName.Length > 0 Then
				indent -= 1
				gen.WriteLine()
				gen.WriteLine("End Namespace")
			End If
			gen.Close()
		End Sub
		Public Sub New(ByVal parser As Parser)
			Me.parser = parser
			tab = parser.tab
			errors = parser.errors
			trace = parser.trace
			firstState = Nothing
			lastState = Nothing
			lastStateNr = -1
			firstState = NewState()
			firstMelted = Nothing
			firstComment = Nothing
			ignoreCase = False
			dirtyDFA = False
			hasCtxMoves = False
		End Sub
	End Class

End Namespace
