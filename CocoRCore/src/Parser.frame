using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using CocoRCore;

-->namespace

    public class Parser : ParserBase 
    {
-->constants
        private const bool _T = true;
        private const bool _x = false;
        
-->declarations

        public Parser()
        {
-->constructor
        }

        public static Parser Create(string fileName) 
            => Create(s => s.Initialize(fileName));

        public static Parser Create() 
            => Create(s => { });

        public static Parser Create(Action<Scanner> init)
        {
            var p = new Parser();
            var scanner = new Scanner();
            p.Initialize(scanner);
            init(scanner);
            return p;
        }


        public override int maxT => __maxT;

        protected override void Get() 
        {
            lb = t;
            t = la;
(((beginalternatives
            if (alternatives != null) 
            {
                tokens.Add(new Alternative(t, alternatives));
            }
            _newAlt();
)))endalternatives
            for (;;) 
            {
                la = scanner.Scan();
                if (la.kind <= maxT) 
                { 
                    ++errDist; 
                    break; // it's not a pragma
                }
                // pragma code
-->pragmas
            }
        }


-->productions

        public override void Parse() 
        {
            if (scanner == null) throw new FatalError("This parser is not Initialize()-ed.");
            lb = Token.Zero;
            la = Token.Zero;
            Get();
-->parseRoot
        }
    
        // a token's base type
        public static readonly int[] tBase = {
-->tbase
        };
		protected override int BaseKindOf(int kind) => tBase[kind];

        // a token's name
        public static readonly string[] varTName = {
-->tname
        };
        public override string NameOfTokenKind(int tokenKind) => varTName[tokenKind];


        // as set0 but with token inheritance taken into account
        static readonly bool[,] set = {
-->initialization
        };

        protected override bool StartOf(int s, int kind) => set[s, kind];

(((beginastcode
        public readonly AST.Builder astbuilder; // can also be private  
        public AST ast { get { return astbuilder.current; }}
)))endastcode


        public override string Syntaxerror(int n) 
        {
            switch (n) 
            {
-->errors
                default: return $"error {n}";
            }
        }

    } // end Parser

// end namespace implicit
