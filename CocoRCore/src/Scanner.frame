-->begin
using System;
using System.IO;
using System.Collections.Generic;
using CocoRCore;

-->namespace



	//-----------------------------------------------------------------------------------
	// Scanner
	//-----------------------------------------------------------------------------------
	public class Scanner : ScannerBase
	{
	-->declarations

		private static readonly Dictionary<int, int> start = new Dictionary<int, int>(); // maps first token character to start state
		static Scanner() 
		{
	-->initialization
		}
	
		public static Scanner Create(string fileName)
		{
			return Create(fileName, false);
		}

		public static Scanner Create(string fileName, bool isBOMFreeUTF8)
		{
			var s = new Scanner();
			s.Initialize(fileName, isBOMFreeUTF8);
			return s;
		}

		public static Scanner Create(Stream st)
		{
			return Create(st, false);
		}

		public static Scanner Create(Stream st, bool isBOMFreeUTF8)
		{
			var s = new Scanner();
			s.Initialize(st, isBOMFreeUTF8);
			return s;
		}
		
		protected override int maxT => _maxT;
		
		protected override void NextCh()
		{
			if (oldEols > 0) { ch = EOL; oldEols--; } 
			else 
			{
				pos = buffer.Pos;
				// buffer reads unicode chars, if UTF8 has been detected
				ch = buffer.Read(); col++; charPos++;
				// replace isolated '\r' by '\n' in order to make
				// eol handling uniform across Windows, Unix and Mac
				if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
				if (ch == EOL) { line++; col = 0; }
			}
			//if (pos <= 10) Console.Write("{0:X} ", ch);
			//casing1 start
	-->casing1
			//casing1 end
		}

		protected override void AddCh() 
		{
			if (tlen >= tval.Length) 
			{
				char[] newBuf = new char[2 * tval.Length];
				Array.Copy(tval, 0, newBuf, 0, tval.Length);
				tval = newBuf;
			}
			if (ch != Buffer.EOF) 
			{
				//casing2 start
	-->casing2
				//casing2 end
				NextCh();
			}
		}


	-->comments

		protected override void CheckLiteral() 
		{
	-->literals
		}

		protected override Token NextToken() 
		{
			while (ch == ' ' ||
	-->scan1
			) NextCh();
	-->scan2
			int recKind = noSym;
			int recEnd = pos;
			t = new Token();
			t.pos = pos; t.col = col; t.line = line; t.charPos = charPos;
			int state;
			state = start.ContainsKey(ch) ? start[ch] : 0;
			tlen = 0; AddCh();
			
			switch (state) 
			{
				case -1: { t.kind = eofSym; break; } // NextCh already done
				case 0: 
					{
						if (recKind != noSym) 
						{
							tlen = recEnd - t.pos;
							SetScannerBehindT();
						}
						t.kind = recKind; break;
					} // NextCh already done
	-->scan3
			}
			t.val = new String(tval, 0, tlen);
			return t;
		}
		
	} // end Scanner

